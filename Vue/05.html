<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../Spring%20in%20Action%205/base.css">
    <title>Vue 05 Vue操作表单</title>
    <script src="vue.js"></script>
</head>
<body>
<ol>
    <li><a href="#con1">基本用法：v-model双向绑定</a></li>
    <li><a href="#con2">单选按钮Radio</a></li>
    <li><a href="#con3">复选框Checkbox</a></li>
    <li><a href="#con4">v-pre 不渲染</a></li>
    <li><a href="#con5">{{表达式}}</a></li>
    <li><a href="#con6">filters 过滤器</a></li>
    <li><a href="#con7">计算属性的getter和setter方法</a></li>
    <li><a href="#con8">用key属性鉴别独立性</a></li>
    <li><a href="#con9">总结</a></li>
</ol>
<h1 id="con1"><code>v-model</code>双向绑定</h1>
<p>双向绑定以后，表单显示的值只依赖于绑定的数据，不再使用初始化的value属性，在textarea标签之间插入的值也不生效。</p>
<p><code>v-model</code>其实是一个语法糖，也可以用@input方法来改写。实际上是自动监听input事件。</p>
<p>使用v-model的例子：</p>
<pre>
&lt;div id="model">
    &lt;input type="text" v-model="message">
    &lt;p>{{message}}&lt;/p>
&lt;/div>
&lt;script>
    var app2 = new Vue({
        el: "#model",
        data: {
            message: ""
        }
    })
&lt;/script>
</pre>
<p>还原成监听input时间的例子：</p>
<pre>
&lt;div id="app">
    &lt;input type="text" @input="handleInput" placeholder="输入...">
    &lt;p>{{message}}&lt;/p>
&lt;/div>
&lt;script>
    var app = new Vue({
        el: "#app",
        data: {
            message: ""
        },
        methods: {
            handleInput: function (e) {
                this.message = e.target.value;
            }
        }
    });
&lt;/script>
</pre>


<h1 id="con2">单选按钮Radio</h1>
<p>单独使用单选按钮，只需要使用其checked属性，绑定一个Vue实例的布尔值属性即可表示选中与否。只需要更改Vue实例的布尔值属性，就可以改变选中的状态。</p>
<pre>
&lt;div id="app2">
    &lt;label>男性
    &lt;input type="radio" :checked="check">
    &lt;/label>
&lt;/div>
&lt;script>
    var app2 = new Vue({
        el: "#app2",
        data: {
            check: true
        }
    })
&lt;/script>
</pre>
<p>使用多个单选按钮，主要是为了获得被选中的项目的name和value，一般也可能是动态生成的按钮。如果是依赖HTML，则radio控件的name必须相同。</p>
<p>有了Vue之后，无需设置name，只需要把一批按钮都通过v-model绑定给一个属性即可。实际上，只要绑定了同一个属性，即使name不同也没事，所以一般就不设置name属性了。</p>
<pre>
&lt;div id="app3">
    &lt;label>A&lt;input type="radio" v-model="alpha" value="A">&lt;/label>
    &lt;label>B&lt;input type="radio" v-model="alpha" value="B">&lt;/label>
    &lt;label>C&lt;input type="radio" v-model="alpha" value="C">&lt;/label>
    &lt;p>被选中的Radio的Value是：{{alpha}}&lt;/p>
&lt;/div>
&lt;script>
    var app3 = new Vue({
        el:"#app3",
        data:{
            alpha: ""
        }
    })
&lt;/script>
</pre>




<h1 id="con3">复选框Checkbox</h1>
<p>Checkbox单独使用的时候也是直接绑定v-model和checked属性即可。绑定布尔值也可以，但是做不到双向绑定，只能通过Vue实例去控制，所以v-model略好。</p>
<pre>
&lt;div id="app4">
    &lt;label>A &lt;input type="checkbox" value="3" :checked="checked">&lt;/label>
    &lt;p>选择状态： {{checked}}&lt;/p>
&lt;/div>
&lt;script>
    var app4 = new Vue({
        el:"#app4",
        data:{
            checked: false
        }
    })
&lt;/script>
</pre>
<p>多个复选框的时候，略有变化，单选框是选一个值，而复选框是一系列value属性。</p>
<p>所以这里Vue要绑定的属性是一个数组，与单选框类似，无需设置name，将所有需要复选的内容用v-model绑定到一个Vue实例上即可。</p>





















<h1 id="con4">v-pre 不编译</h1>
<p>加在元素上之后不进行该元素和其所有子元素的渲染，原样输出</p>

<h1 id="con5">{{ 表达式的限制 }}</h1>
<p>在双花括号之间的表达式，只能是单个表达式，变量只能使用Vue实例的变量，不能使用语句和表达式。</p>
<p>一些全局变量，只能使用Vue白名单之内的全局变量，先理解为JS自带的Math和Date等变量。</p>

<h1 id="con6">filters 过滤器</h1>
<p>很像Django模板渲染的过滤器，用一个管道符号加上过滤器的标识符即可。实际上是将管道符前边的内容交给后边的过滤器进行处理，渲染成处理后的内容。</p>
<p>过滤器是Vue实例中的filters属性，键值对为过滤器名称：匿名方法。</p>
<pre>
var myData = {
        a: 10,
        date: new Date()
    };

var app = new Vue({
        el: "#app",
        data: myData,
        created: function () {
            console.log(this.a);
            this.a = 30;
        },
        mounted: function () {
            var _this = this;
            this.timer = setInterval(function () {
                _this.date = new Date();
            }, 1000);
        },
        filters: {
            filterDate: function (value) {
                return value + " 过滤后的内容";
            }
        }
    }
);
</pre>
<p>过滤器实际上是以被过滤对象为参数的函数，过滤器还可以串联。还可以传入额外的参数。第一个参数默认是被过滤的对象。</p>
<pre>
&lt;div id="app">
    {{date|filterDate|filter2("gugugug","saner")}}
&lt;/div>

&lt;script src="vue.js">&lt;/script>
&lt;script>
    var myData = {
        a: 10,
        date: new Date()
    };

    var app = new Vue({
            el: "#app",
            data: myData,
            created: function () {
                console.log(this.a);
                this.a = 30;
            },
            mounted: function () {
                var _this = this;
                this.timer = setInterval(function () {
                    _this.date = new Date();
                }, 1000);
            },
            filters: {
                filterDate: function (value) {
                    return value + " 过滤后的内容";
                },
                filter2: function (value,a,b) {
                    return value + a + b;
                }
            }
        }
    );
&lt;/script>
</pre>
<p>过滤器常用于处理简单的文本变换，如果要处理更加复杂的逻辑，一般使用计算属性。</p>


<h1 id="con7">计算属性的getter和setter方法</h1>
<p>计算属性除了直接设置为一个匿名函数之外，还可以设置为get和set对应的对象，读取计算属性就是调用get方法，直接设置计算属性就会调用set方法。</p>
<pre>
var app = new Vue({
            el: "#app",
            data: {
                a:10
            },
            computed: {
                realA:{get:function () {
                        var b = parseInt(Math.random() * 10) + this.a;
                        return b;},
                    set:function (value) {
                        console.log("Set被触发了");
                    }
                },
                now:function () {
                    return Date.now();
                }
            }
        }
    );
</pre>
<p>如果直接显示a的值，发现每次都是随机的。如果直接设置a的值，就会在控制台打印出语句。get函数的return就是实际计算出的值，而set函数中的value参数就是要设置的值。</p>
<p>计算属性牛逼的是可以依赖其他计算变量，以及依赖其他Vue实例的变量，这样在组件化的时候非常方便。</p>
<p>计算属性和函数的区别是计算属性有缓存，依赖的内容没有变化，就不会重新计算，所以如果一个计算变量没有依赖，那么也不会更新，而函数只要调用就会更新。上边的now计算属性只要生成了，就一直不会自动变化。</p>


</body>
</html>