<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../Spring%20in%20Action%205/base.css">
    <title>Vue 07 组件通信</title>
    <script src="vuejs实战/vue.js"></script>
</head>
<body>
<ol>
    <li><a href="#con1">组件通信综述</a></li>
    <li><a href="#con2">子组件向父组件传递数据：v-on监听自定义事件</a></li>
    <li><a href="#con3">子组件向父组件传递数据：v-model绑定</a></li>
    <li><a href="#con4">非父子组件通信</a></li>
    <li><a href="#con5">使用slot</a></li>
    <li><a href="#con6">父组件向子组件传递数据：props使用字符串数组</a></li>
    <li><a href="#con7">单向数据流</a></li>
    <li><a href="#con8">父组件向子组件传递数据：props使用对象</a></li>
    <li><a href="#con9">组件通信</a></li>
</ol>
<h1 id="con1">组件通信</h1>
<p>父组件单向将数据传递给子组件只是通信的一种方式。实际上组件通信可以分为：</p>
<ol>
    <li>父子组件通信</li>
    <li>兄弟组件通信</li>
    <li>跨级组件通信</li>
</ol>
<p>这些还都分为单向和双向。在组件中学习的props只是父组件传数据给子组件的方式。还有很多传递数据的方式。</p>


<h1 id="con2">子组件向父组件传递数据</h1>
<p>Vue提供了子组件用<code>$emit()</code>来触发事件，父组件<code>$on()</code>来监听子组件的事件。</p>
<p>在实际开发中，可以在子组件的标签上使用v-on来监听子组件触发的自定义事件</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{count}}&lt;/p>
    &lt;my-comp :child-count="count" <span style="color: red;">@event-from-child="fatherFunction"</span>>&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                props:["childCount"],
                template: "&lt;div>" +
                    "&lt;button @click='myFunction1'>++&lt;/button>" +
                    "&lt;button @click='myFunction2'>--&lt;/button>&lt;/div>",
                methods: {
                    myFunction1: function () {
                        this.initCount++;
                        <span style="color: red">this.$emit('event-from-child', this.initCount);</span>
                    },
                    myFunction2: function () {
                        this.initCount--;
                        <span style="color: red">this.$emit('event-from-child', this.initCount);</span>
                    }
                },
                data: function () {
                    return {
                        initCount: this.childCount
                    }
                }
            }
        },
        data: {
            message: [1, 2, 3, 4, 5],
            count: 0
        },
        methods: {
            fatherFunction(value) {
                console.log("从子组件传来的数据是：" + value);
            }
        }
    })
&lt;/script>
</pre>
<p>注意这里红色的几行。先看子组件，子组件从父组件接收了count属性，并用一个initCount存放了这个属性。这样做到数据和父组件隔离。</p>
<p>此后子组件两个按钮定义了两个事件，一个减少自己的initCount，一个增加自己的initCount，然后使用了特殊的<code>$emit(自定义事件名称，数据)</code>方法来生成一个自定义事件。</p>
<p>父组件将这个自定义事件的名称写在子组件的元素标签内，对其监听并用自己的<code>fatherFunction</code>去处理。</p>
<p><code>fatherFunction</code>参数直接就是子组件传递来的数据。子组件的<code>$emit</code>可以传递多个数据参数，在父组件的事件内也提供同样多的参数进行接收即可。</p>
<p>通过自定义事件，就可以实现子组件向父组件传递数据。</p>
<p>除了直接监听自定义事件之外，还可以监听原生的DOM事件，在上边的例子里如果还想监听子组件内所有的按钮被按下的事件，可以增加如下代码：</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{count}}&lt;/p>
    &lt;my-comp :child-count="count" @event-from-child="fatherFunction" <span style="color: red">@click.native="clickhandler"</span>>&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                props: ["childCount"],
                template: "&lt;div>" +
                    "&lt;button @click='myFunction1'>++&lt;/button>" +
                    "&lt;button @click='myFunction2'>--&lt;/button>&lt;/div>",
                methods: {
                    myFunction1: function () {
                        console.log(this.initCount);
                        this.$emit('event-from-child', this.initCount, this.initCount + 10, this.initCount + 100);
                        this.initCount++;
                    },
                    myFunction2: function () {
                        console.log(this.initCount);
                        this.$emit('event-from-child', this.initCount, this.initCount + 10, this.initCount + 100);
                        this.initCount--;
                    }
                },
                data: function () {
                    return {
                        initCount: this.childCount
                    }
                }
            }
        },
        data: {
            message: [1, 2, 3, 4, 5],
            count: 0
        },
        methods: {
            fatherFunction(value, value1, value2) {
                console.log("从子组件传来的数据是：" + value);
                console.log("从子组件传来的数据是：" + value1);
                console.log("从子组件传来的数据是：" + value2);
            },
            <span style="color: red">clickhandler:function () {
                console.log("我被按了");
            }</span>
        }
    })
&lt;/script>
</pre>


<h1 id="con3">v-model监听事件</h1>
<p>v-model其实是一个语法糖，会自动监听input事件并从中获得数据，本质上还是监听自定义事件。看一个简单的例子</p>
<pre>
&lt;div id="app">
    &lt;p v-if="total">从子组件传来的数据是{{total}}&lt;/p>
    &lt;my-comp v-model="total">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;button @click='myFunction'>++&lt;/button>&lt;/div>",
                methods: {
                    myFunction: function () {
                        this.count++;
                        this.$emit('input', this.count);
                    },
                },
                data: function () {
                    return {
                        count: 0
                    }
                }
            }
        },
        data: {
            total: 0
        },
        methods: {
            fatherFunction(value) {
                this.total = value;
                console.log("从子组件传来的数据是：" + value);
            },
        }
    })
&lt;/script>
</pre>
<p>这个东西其实就是一个语法糖，需要使用v-model语法糖，需要满足两个条件：</p>
<ol>
    <li>v-model在子组件元素上绑定父组件一个data属性</li>
    <li>子组件必须使用<code>$emit</code>产生名称为<code>input</code>的事件并传递一个value值</li>
</ol>
<p>有了父子组件通信之后，很多想法就可以实现了，比如组件是一个表单，接受输入之后传给父组件。</p>


<h1 id="con4">非父子组件通信</h1>
<p>很多时候可能还需要非父子组件之间通信，比如两个各渲染一块内容的组件通信。</p>
<p>这个时候推荐用一个专门的Vue实例，来做事件中介。在进阶的时候再来学习这个。</p>
<p>现在先来看两种方式：</p>
<ol>
    <li>父链</li>
    <li>子组件索引</li>
</ol>
<p>父链其实就是在组件中去直接访问父级组件和子组件，采用<code>this.$parent</code>就可以访问当前组件的父级组件，<code>this.$children</code>则可以访问子组件。</p>
<p>可以一层一层向上或者向下访问，可以取得对组件的完全控制。</p>
<p>尽管父链和子链是Vue提供的功能，但实际中最好不要去写直接操作父子组件的代码，这样会造成高耦合，如果是单纯的父子组件，最好还是使用之前介绍的通信方法。</p>
<p>一个父组件有多个子组件是很常见的，如果通过<code>this.$children</code>遍历，由于渲染顺序不固定，比较麻烦。Vue提供了子组件索引的方法，用<code>ref</code>属性再子组件标签上为子组件指定一个索引名称，之后就可以比较方便的通过<code>this.$refs.xxx</code>访问该子组件。</p>
<pre>
&lt;div id="app">
    &lt;button @click="clickhandler">从子组件获取消息&lt;/button>
    &lt;my-comp ref="child">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;button>++&lt;/button>&lt;/div>",
                data: function () {
                    return {
                        count: 0,
                        message: "子组件的内容"
                    }
                }
            }
        },
        data: {
            total: 0,
            message:""
        },
        methods: {
            clickhandler() {
                this.message = this.$refs.child.message;
                console.log("从子组件传来的数据是：" + this.message);
            },
        }
    })
&lt;/script>
</pre>



<h1 id="con5">使用slot</h1>
<p>有的时候需要混合父组件与子组件的模板，就会用到slot，就是内容分发。</p>
<p>用一个形象的说明就是，一个子组件模板的一块区域是留给父组件的，像一个插槽一样，其实际渲染的部分，是父组件渲染出来的。</p>
<p>一个Vue组件对外交互的API，其实就是三块内容，之前学过了props，还有事件传递，现在还有第三个，就是slot。</p>
<pre>
&lt;div id="app">
    &lt;my-comp>&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>{{message}}&lt;/p>&lt;input type='text' v-model='message'>&lt;p>&lt;button @click='alertMessage'>alert&lt;/button>&lt;/p>&lt;/div>",
                data:function () {
                    return {
                        message:"组件的message属性",
                        count: 0
                    }
                },
                methods:{
                    alertMessage:function() {
                        this.count++;
                        console.log(this.message + this.count);
                    }
                }
            }
        }

    })
&lt;/script>
</pre>
<p>这里直接去访问了子组件的属性，直接从中获取了数据。注意<code>$refs</code>是非响应式的，也就是访问一次赋值一次，在computed或者模板中最好不要使用。这其实是一个应急方案。</p>
<p>此外如果把ref标签写在普通的标签上，则不会被解释为子组件引用。</p>



<h1 id="con6">父组件向子组件传递数据</h1>
<p>为什么要有组件，主要是为了可以方便的复用。想象一下这个场景：在一个聊天页面中，很多地方都需要显示用户的名称。</p>
<p>如果不使用组件，而是使用Vue实例控制每个小区域，那么这些组件都要互相去找用户使用的名称。</p>
<p>如果使用组件，让组件进行父子组件之间的通信，只要给父组件传递数据，数据就自动会被放到子组件中更新和处理，就会非常方便，也利于解耦。</p>
<p><code>props</code>属性用于在组件中声明需要从父组件中接收的数据，值可以有两种，一种是字符串数组代表的各个变量名称，一种是对象。</p>
<p>先来看一个字符串数组的例子</p>
<pre>
&lt;div id="app">
    &lt;my-comp message="From Father Vue instance">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
            el: "#app",
            components: {
                "my-comp": {
                    template: "&lt;div>&lt;p>{{message}}&lt;/p>&lt;/div>",
                    props: ['message'],
                    data:function () {
                        return {
                            count: 0
                        }
                    }
                }
            }
        })
&lt;/script>
</pre>
<p>props属性中的字符串数据中的每一个元素实际上是属性名称，就和data返回的count属性一样可以在子组件的作用域内使用。二者的不同是data返回的属性只能在子组件作用域内使用，而props的值来自于父级。要传递多个</p>
<p>如果把父组件的传递的内容绑定上属性，在父组件内就可以控制子组件的数据了：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message="mess">&lt;/my-comp>
    &lt;input type="text" v-model="mess">
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>{{message}}&lt;/p>&lt;p>{{message2}}&lt;/p>&lt;/div>",
                props: ['message'],
                data:function () {
                    return {
                        count: 0
                    }
                }
            }
        },
        data:{
            mess: ""
        }
    })
&lt;/script>
</pre>
<p>这个例子是把父组件传递给子组件的数据绑定给父组件的input框，输入什么，子组件就显示什么。</p>
<p>唯一要注意的是如果在HTML属性名中使用了减号，props中的属性名称要写成驼峰：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message-new="mess">&lt;/my-comp>
    &lt;input type="text" v-model="mess">
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>{{messageNew}}&lt;/p>&lt;/div>",
                props: ['messageNew'],
                data:function () {
                    return {
                        count: 0
                    }
                }
            }
        },
        data:{
            mess: ""
        }
    })
&lt;/script>
</pre>
<p>如果props里写成了<code>message-new</code>是没有作用的。</p>
<p>使用v-bind的好处是，可以传递除了字符串以外的值。如果直接写死，传递的都是字符串。使用v-bind可以传递对象或者其他类型的数据：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message1="mess" message2="[1,2,3,4]">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>message1的长度是：{{message1.length}}&lt;/p>&lt;p>message2的长度是：{{message2.length}}&lt;/p>&lt;/div>",
                props: ['message1','message2'],
                data:function () {
                    return {
                        count: 0
                    }
                }
            }
        },
        data:{
            mess: [1,2,3,4]
        }
    })
&lt;/script>
</pre>
<p>可以看到message1的长度是4，即数组的元素数，而message2的长度是9，是字符串的长度。</p>
<p>这里只需要在<code>&lt;my-comp :message1="mess" message2="[1,2,3,4]">&lt;/my-comp></code>中，将<code>message2</code>前边加上一个<code>:</code>或者<code>v-bind:</code>指令，传给子组件的就是js表达式解析出的数组而不是字符串了。</p>


<h1 id="con7">单向数据流</h1>
<p>为什么要提到单向数据流，因为在Vue 1.x中，子组件修改props属性会连带修改父组件的数据。在Vue 2.x中就不行了，这是避免子组件污染父组件。看这个例子：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message="mess">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>message是：{{message}}&lt;/p>&lt;button @click='modify'>修改子组件数据&lt;/button>&lt;/div>",
                props: ['message'],
                data:function () {
                    return {
                        count: 0
                    }
                },
                methods:{
                    modify:function () {
                        this.message++;
                    }
                }
            }
        },
        data:{
            mess: 100
        }
    })
&lt;/script>
</pre>
<p>父组件传给子组件一个数据是100，子组件用按钮来直接将其自增。每点一次按钮，控制台内会有Vue的警告：</p>
<pre>
vue.js:634 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "message"
found in
---> &lt;MyComp>
       &lt;Root>
</pre>
<p>这里会警告不要直接修改父组件的对应数据，实际上也没能修改成功，在控制台里查看<code>app.mess</code>依然是100。</p>
<p>但是这样很不好，父子组件的数据其实没同步。Vue也给出了解决方案，就是在data里创建一个自己的局部变量用来接受初始值，或者使用计算属性基于传进来的值计算出新的值。</p>
<p>例子可以修改成这样：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message="mess">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>initCount是：{{initCount}}&lt;/p>&lt;p>计算后的是{{computedCount}}&lt;/p>&lt;button @click='modify'>修改子组件数据&lt;/button>&lt;/div>",
                props: ['message'],
                data:function () {
                    return {
                        initCount: this.message
                    }
                },
                methods:{
                    modify:function () {
                        this.initCount++;
                    }
                },
                computed:{
                    computedCount: function () {
                        return this.initCount + 100000;
                    }
                }
            }
        },
        data:{
            mess: 100
        }
    })
&lt;/script>
</pre>
<p>不过要注意的是，如果传递了一个对象比如数组，由于JS传递的是引用，所以依然会被修改：</p>
<pre>
&lt;div id="app">
    &lt;my-comp :message="mess">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;p>initCount是：{{initCount}}&lt;/p>&lt;p>计算后的是{{computedCount}}&lt;/p>&lt;button @click='modify'>修改子组件数据&lt;/button>&lt;/div>",
                props: ['message'],
                data:function () {
                    return {
                        initCount: this.message
                    }
                },
                methods:{
                    modify:function () {
                        this.initCount.push(666);
                    }
                },
                computed:{
                    computedCount: function () {
                        return this.initCount.length;
                    }
                }
            }
        },
        data:{
            mess: [1, 2, 3, 4, 5]
        }
    })
&lt;/script>
</pre>
<p>每次点击按钮，查看父组件的mess属性，会发现也一并发生了变化。</p>
<p>因此子组件最好不要直接修改父组件的数据，尤其父组件的数据还有其他用途的时候。</p>

<h1 id="con8">props传递对象</h1>
<p>当传入的数据需要验证的时候，就可以使用对象传递，并在每个属性名后跟上需要验证的类型，有特定的写法，看几个例子：</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{message}}&lt;/p>
    &lt;my-comp :message6="message">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>{{message6}}&lt;/div>",
                props: {
                    // 传入Number类型的值
                    message1:Number,

                    //String和Number类型
                    message2:[String,Number],

                    //布尔类型，默认是true
                    message3:{
                        type:Boolean,
                        default: true
                    },

                    //Number类型的必传值
                    message4:{
                        type: Number,
                        required: true
                    },

                    //数组或者对象类型，必须用一个函数来返回
                    message5:{
                        type:Array,
                        default: function () {
                            return []
                        }
                    },

                    //自定义验证器
                    message6:{
                        validator:function (value) {
                            return value.length >= 5 && value instanceof Array;
                        }
                    }
                },
            }
        },
        data: {
            message: [1, 3, 4, 5,5]
        }
    })
&lt;/script>
</pre>
<p>如果类型不匹配，在控制台里可以看到警告。</p>
<p>type支持的类型有：String，Number，Boolean，Object，Array，Function。type也可以传入一个自定义验证器，用instanceof来验证：</p>
<pre>
message5:{
    type:function (obj) {
        return obj instanceof Function;
    },
    default: function () {
        return []
    }
},
</pre>

<h1 id="con9">组件通信</h1>
<p>父组件单向将数据传递给子组件只是通信的一种方式。实际上组件通信可以分为：</p>
<ol>
    <li>父子组件通信</li>
    <li>兄弟组件通信</li>
    <li>跨级组件通信</li>
</ol>
<p>这些还都分为单向和双向。刚才的只是父组件单向传递数据给子组件。</p>


















</body>
</html>