<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../Spring%20in%20Action%205/base.css">
    <title>Vue 07 组件通信</title>
    <script src="vuejs实战/vue.js"></script>
</head>
<body>
<ol>
    <li><a href="#con1">组件通信综述</a></li>
    <li><a href="#con2">子组件向父组件传递数据：v-on监听自定义事件</a></li>
    <li><a href="#con3">子组件向父组件传递数据：v-model绑定</a></li>
    <li><a href="#con4">非父子组件通信</a></li>
    <li><a href="#con5">使用slot</a></li>
    <li><a href="#con6">父组件向子组件传递数据：props使用字符串数组</a></li>
    <li><a href="#con7">作用域插槽</a></li>
    <li><a href="#con8">父组件向子组件传递数据：props使用对象</a></li>
    <li><a href="#con9">组件通信</a></li>
</ol>
<h1 id="con1">组件通信</h1>
<p>父组件单向将数据传递给子组件只是通信的一种方式。实际上组件通信可以分为：</p>
<ol>
    <li>父子组件通信</li>
    <li>兄弟组件通信</li>
    <li>跨级组件通信</li>
</ol>
<p>这些还都分为单向和双向。在组件中学习的props只是父组件传数据给子组件的方式。还有很多传递数据的方式。</p>


<h1 id="con2">子组件向父组件传递数据</h1>
<p>Vue提供了子组件用<code>$emit()</code>来触发事件，父组件<code>$on()</code>来监听子组件的事件。</p>
<p>在实际开发中，可以在子组件的标签上使用v-on来监听子组件触发的自定义事件</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{count}}&lt;/p>
    &lt;my-comp :child-count="count" <span style="color: red;">@event-from-child="fatherFunction"</span>>&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                props:["childCount"],
                template: "&lt;div>" +
                    "&lt;button @click='myFunction1'>++&lt;/button>" +
                    "&lt;button @click='myFunction2'>--&lt;/button>&lt;/div>",
                methods: {
                    myFunction1: function () {
                        this.initCount++;
                        <span style="color: red">this.$emit('event-from-child', this.initCount);</span>
                    },
                    myFunction2: function () {
                        this.initCount--;
                        <span style="color: red">this.$emit('event-from-child', this.initCount);</span>
                    }
                },
                data: function () {
                    return {
                        initCount: this.childCount
                    }
                }
            }
        },
        data: {
            message: [1, 2, 3, 4, 5],
            count: 0
        },
        methods: {
            fatherFunction(value) {
                console.log("从子组件传来的数据是：" + value);
            }
        }
    })
&lt;/script>
</pre>
<p>注意这里红色的几行。先看子组件，子组件从父组件接收了count属性，并用一个initCount存放了这个属性。这样做到数据和父组件隔离。</p>
<p>此后子组件两个按钮定义了两个事件，一个减少自己的initCount，一个增加自己的initCount，然后使用了特殊的<code>$emit(自定义事件名称，数据)</code>方法来生成一个自定义事件。</p>
<p>父组件将这个自定义事件的名称写在子组件的元素标签内，对其监听并用自己的<code>fatherFunction</code>去处理。</p>
<p><code>fatherFunction</code>参数直接就是子组件传递来的数据。子组件的<code>$emit</code>可以传递多个数据参数，在父组件的事件内也提供同样多的参数进行接收即可。</p>
<p>通过自定义事件，就可以实现子组件向父组件传递数据。</p>
<p>除了直接监听自定义事件之外，还可以监听原生的DOM事件，在上边的例子里如果还想监听子组件内所有的按钮被按下的事件，可以增加如下代码：</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{count}}&lt;/p>
    &lt;my-comp :child-count="count" @event-from-child="fatherFunction" <span style="color: red">@click.native="clickhandler"</span>>&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                props: ["childCount"],
                template: "&lt;div>" +
                    "&lt;button @click='myFunction1'>++&lt;/button>" +
                    "&lt;button @click='myFunction2'>--&lt;/button>&lt;/div>",
                methods: {
                    myFunction1: function () {
                        console.log(this.initCount);
                        this.$emit('event-from-child', this.initCount, this.initCount + 10, this.initCount + 100);
                        this.initCount++;
                    },
                    myFunction2: function () {
                        console.log(this.initCount);
                        this.$emit('event-from-child', this.initCount, this.initCount + 10, this.initCount + 100);
                        this.initCount--;
                    }
                },
                data: function () {
                    return {
                        initCount: this.childCount
                    }
                }
            }
        },
        data: {
            message: [1, 2, 3, 4, 5],
            count: 0
        },
        methods: {
            fatherFunction(value, value1, value2) {
                console.log("从子组件传来的数据是：" + value);
                console.log("从子组件传来的数据是：" + value1);
                console.log("从子组件传来的数据是：" + value2);
            },
            <span style="color: red">clickhandler:function () {
                console.log("我被按了");
            }</span>
        }
    })
&lt;/script>
</pre>


<h1 id="con3">v-model监听事件</h1>
<p>v-model其实是一个语法糖，会自动监听input事件并从中获得数据，本质上还是监听自定义事件。看一个简单的例子</p>
<pre>
&lt;div id="app">
    &lt;p v-if="total">从子组件传来的数据是{{total}}&lt;/p>
    &lt;my-comp v-model="total">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;button @click='myFunction'>++&lt;/button>&lt;/div>",
                methods: {
                    myFunction: function () {
                        this.count++;
                        this.$emit('input', this.count);
                    },
                },
                data: function () {
                    return {
                        count: 0
                    }
                }
            }
        },
        data: {
            total: 0
        },
        methods: {
            fatherFunction(value) {
                this.total = value;
                console.log("从子组件传来的数据是：" + value);
            },
        }
    })
&lt;/script>
</pre>
<p>这个东西其实就是一个语法糖，需要使用v-model语法糖，需要满足两个条件：</p>
<ol>
    <li>v-model在子组件元素上绑定父组件一个data属性</li>
    <li>子组件必须使用<code>$emit</code>产生名称为<code>input</code>的事件并传递一个value值</li>
</ol>
<p>有了父子组件通信之后，很多想法就可以实现了，比如组件是一个表单，接受输入之后传给父组件。</p>


<h1 id="con4">非父子组件通信</h1>
<p>很多时候可能还需要非父子组件之间通信，比如两个各渲染一块内容的组件通信。</p>
<p>这个时候推荐用一个专门的Vue实例，来做事件中介。在进阶的时候再来学习这个。</p>
<p>现在先来看两种方式：</p>
<ol>
    <li>父链</li>
    <li>子组件索引</li>
</ol>
<p>父链其实就是在组件中去直接访问父级组件和子组件，采用<code>this.$parent</code>就可以访问当前组件的父级组件，<code>this.$children</code>则可以访问子组件。</p>
<p>可以一层一层向上或者向下访问，可以取得对组件的完全控制。</p>
<p>尽管父链和子链是Vue提供的功能，但实际中最好不要去写直接操作父子组件的代码，这样会造成高耦合，如果是单纯的父子组件，最好还是使用之前介绍的通信方法。</p>
<p>一个父组件有多个子组件是很常见的，如果通过<code>this.$children</code>遍历，由于渲染顺序不固定，比较麻烦。Vue提供了子组件索引的方法，用<code>ref</code>属性再子组件标签上为子组件指定一个索引名称，之后就可以比较方便的通过<code>this.$refs.xxx</code>访问该子组件。</p>
<pre>
&lt;div id="app">
    &lt;button @click="clickhandler">从子组件获取消息&lt;/button>
    &lt;my-comp ref="child">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;button>++&lt;/button>&lt;/div>",
                data: function () {
                    return {
                        count: 0,
                        message: "子组件的内容"
                    }
                }
            }
        },
        data: {
            total: 0,
            message:""
        },
        methods: {
            clickhandler() {
                this.message = this.$refs.child.message;
                console.log("从子组件传来的数据是：" + this.message);
            },
        }
    })
&lt;/script>
</pre>

<h1 id="con5">使用单个slot</h1>
<p>有的时候需要混合父组件与子组件的模板，就会用到slot，就是内容分发。</p>
<p>用一个形象的说明就是，一个子组件模板的一块区域是留给父组件的，像一个插槽一样，其实际渲染的部分，是父组件渲染出来的。</p>
<p>一个Vue组件对外交互的API，其实就是三块内容，之前学过了props，还有事件传递，现在还有第三个，就是slot。</p>
<p>在子组件内使用特殊的<code>&lt;slot&gt;</code>就可以为这个组件开启一个插槽，父组件可以把渲染的内容插进来。</p>
<pre>
&lt;div id="app">
    &lt;my-comp>
        <span style="color: red;">&lt;p>{{fathermessage}}&lt;/p></span>
    &lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;slot>&lt;p>子组件的默认内容&lt;/p>&lt;/slot>&lt;/div>",
                data: function () {
                    return {
                        count: 0,
                    }
                }
            }
        },
        data: {
            fathermessage: "父组件的信息",
        }
    })
&lt;/script>
</pre>
<p>在子组件元素中的内容，也就是<code>&lt;p>{{fathermessage}}&lt;/p></code>，是父组件插入给子组件的内容，注意这里的作用域是父组件而不是子组件。</p>
<p>在子组件的slot标签中的HTML元素，是父组件没有插入内容的时候，默认显示的内容。slot标签中的内容是子组件的作用域。</p>
<p>这个例子渲染之后的实际结果是父组件的信息，如果删除<code>&lt;p>{{fathermessage}}&lt;/p></code>，则会显示子组件的默认内容。</p>



<h1 id="con6">具名slot</h1>
<p>在父组件的渲染区域，可以给<span style="color: red">元素上添加slot属性</span>，用于指定一个命名的插槽。在组件内，则要通过<span style="color: red">slot标签的name属性</span>来指定对应名称的插槽。</p>
<p>指定了名称之后，父组件渲染的元素就会插到子组件同名的插槽中。如果子组件有一个不带有name属性的slot标签，则父元素所有不具名的插入元素都会被收集到这个无名的slot标签中。</p>
<pre>
&lt;div id="app">
    &lt;my-comp>
        &lt;p slot="slot1">这是插入给slot1插槽的内容&lt;/p>
        &lt;p slot="slot2">这是插入给slot2插槽的内容&lt;/p>
        &lt;p>这是父元素的不具名插槽的内容&lt;/p>
    &lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;slot name='slot2'>&lt;/slot>&lt;slot name='slot1'>&lt;/slot>&lt;slot>&lt;/slot>&lt;/div>",
                data: function () {
                    return {
                        count: 0,
                        message: "子组件的内容"
                    }
                }
            }
        },
        data: {
            total: 0,
            fathermessage: "父组件的信息",
            message: "",
        }
    })
&lt;/script>
</pre>
<p>可以看到父组件渲染的内容分别插入到了不同的插槽中，通过结果页面的顺序就可以看到。如果没有匿名的slot，则父组件所有不具名的slot渲染内容都会被抛弃。</p>
<p>可以看到内容分发API也是非常重要的。</p>

<h1 id="con7">作用域插槽</h1>
<p>作用域插槽使用一个模板替换已经渲染的元素，先看一个例子：</p>
<pre>
&lt;div id="app">
    &lt;my-comp>
        &lt;template slot-scope="props">
            &lt;p>父组件渲染的内容&lt;/p>
            &lt;p>{{props.msg}}&lt;/p>
        &lt;/template>
    &lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>&lt;slot msg='子组件渲染的内容'>&lt;/slot>&lt;/div>",
            }
        }
    })
&lt;/script>
</pre>
<p>这个作用域插槽在Vue 2.5之后，要使用<code>slot-scope</code>属性，这个属性的值是一个临时变量。</p>
<p>在template之内的父组件的渲染内容里，访问这个临时变量中，子组件在插槽上设置的同名属性，即可渲染成具体的值。</p>
<p>这个作用域插槽的意义何在呢？</p>

















<h1 id="con8">props传递对象</h1>
<p>当传入的数据需要验证的时候，就可以使用对象传递，并在每个属性名后跟上需要验证的类型，有特定的写法，看几个例子：</p>
<pre>
&lt;div id="app">
    &lt;p>传给子组件的是{{message}}&lt;/p>
    &lt;my-comp :message6="message">&lt;/my-comp>
&lt;/div>

&lt;script>
    var app = new Vue({
        el: "#app",
        components: {
            "my-comp": {
                template: "&lt;div>{{message6}}&lt;/div>",
                props: {
                    // 传入Number类型的值
                    message1:Number,

                    //String和Number类型
                    message2:[String,Number],

                    //布尔类型，默认是true
                    message3:{
                        type:Boolean,
                        default: true
                    },

                    //Number类型的必传值
                    message4:{
                        type: Number,
                        required: true
                    },

                    //数组或者对象类型，必须用一个函数来返回
                    message5:{
                        type:Array,
                        default: function () {
                            return []
                        }
                    },

                    //自定义验证器
                    message6:{
                        validator:function (value) {
                            return value.length >= 5 && value instanceof Array;
                        }
                    }
                },
            }
        },
        data: {
            message: [1, 3, 4, 5,5]
        }
    })
&lt;/script>
</pre>
<p>如果类型不匹配，在控制台里可以看到警告。</p>
<p>type支持的类型有：String，Number，Boolean，Object，Array，Function。type也可以传入一个自定义验证器，用instanceof来验证：</p>
<pre>
message5:{
    type:function (obj) {
        return obj instanceof Function;
    },
    default: function () {
        return []
    }
},
</pre>

<h1 id="con9">组件通信</h1>
<p>父组件单向将数据传递给子组件只是通信的一种方式。实际上组件通信可以分为：</p>
<ol>
    <li>父子组件通信</li>
    <li>兄弟组件通信</li>
    <li>跨级组件通信</li>
</ol>
<p>这些还都分为单向和双向。刚才的只是父组件单向传递数据给子组件。</p>


















</body>
</html>