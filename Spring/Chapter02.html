<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Spring初步</title>

</head>
<body>
<p>教学视频中采用的是Eclipse作为IDE，先是安装Tomcat9，然后是Eclipse，之后是在Eclipse中配置Tomcat部署。我用的是IntelliJ IDEA 2018 Ultimate 2018.3，就记录一下自己的方式吧。</p>

<h1 style="text-align: center;">Tomcat 和 IntelliJ的配置与连接</h1>
<p>这一步之前的Java EE的时候已经做过了，但是没有系统总结过，就重新做一下吧。</p>
<p>首先Tomcat 9 下载压缩包，然后配置JAVA_HOME和JRE_HOME环境变量，之后是CATALINA_HOME变量，然后到Tomcat的bin目录下启动tomcat，到localhost:8080检测一下就完毕了。</p>
<p>如果不动Tomcat的高深配置，一般就这么简单。</p>
<p>之后是在Intellij里配置Tomcat。其实Intellij并不是从项目中集成Tomcat，而是将Tomcat作为一个构建要素。只要符合目录结构的项目，引入了Tomcat，都可以部署成Web应用。</p>
<p>由于Spring并不一定需要符合Web要素的目录，而是在任何项目中都能够作为一个库导入，所以目前可以采用先创建Web项目，配置Tomcat服务器，然后安装Spring作为第三方库的方式。具体步骤如下：</p>
<ol>
    <li>New Project-->左侧选择Java Enterprise，旁边选择JDK8，然后添加Tomcat服务器，选择安装路径即可，然后勾上下边选项中的Web Application，创建一个Web应用。</li>
    <li>在右上角的Tomcat运行的地方选择配置，可以自定义项目的路径名称和tomcat服务器启动时候的一系列参数。此时可以配置一下Web.xml，测试一个最简单的Web应用是否工作正常。</li>
    <li>导入Spring有两种方式，一种就是像新建一个普通项目的时候一样，创建一个lib目录，然后将Spring的Jar文件放入其中，然后设置成库文件即可，也可以将其配置成External库，通过在Program Structure中添加库。我采用的是直接创建lib目录的方式。Spring自身也可以当成一个普通库使用，所以Web项目里也可以引入。</li>
    <li>Spring的下载地址从 <a href="https://spring.io">spring.io</a>进去显得不够直观，这里放上直接下载地址：<a
            href="http://repo.spring.io/release/org/springframework/spring/">http://repo.spring.io/release/org/springframework/spring/</a>，进去之后选择下载和教学视频中一样的5.0.2版本，和很多库一样，有包，文档和schema三个zip文件，只需要-dist.zip即可，然而文档也是个好东西。</li>
</ol>

<h1 style="text-align: center;">IOC初步接触</h1>
<p>假设我们的应用MyApp.java需要使用如下的三个类/接口（依赖于这三个类）：</p>
<ol>
    <li>Coach.java 一个接口，表示了所有的教练需要实现的共通方法</li>
    <li>BaseballCoach.java</li>
    <li>TrackCoach.java</li>
</ol>
<p>传统的做法是先创建一个MyApp.java类，BaseballCoach和TrackCoach都继承Coach接口</p>
<pre>
public interface Coach {
    public String getDailyWorkout();
}

public class BaseballCoach implements Coach {
    @Override
    public String getDailyWorkout() {
        return "I am BaseballCoach";
    }
}

public class TrackCoach implements Coach {
    @Override
    public String getDailyWorkout() {
        return "I am TrackCoach";
    }
}

public class MyApp {
    public static void main(String[] args) {
        //创建依赖的对象
        BaseballCoach theCoach = new BaseballCoach();
        //调用对象的方法
        System.out.println(theCoach.getDailyWorkout());
    }
}
</pre>
<p>那么现在MyApp如果需要与TrackCoach进行交互，则不得不修改MyApp的源代码，将其中的BaseballCoach对象全部替换成TrackCoach对象，因为这里写死了一个具体的对象。</p>
<p>如果对象的依赖发生改变，则需要手工修改全部使用该对象的代码，这样导致MyApp只能和一个具体的实现绑定在一起。</p>
<p>在Spring中的做法不是修改源代码，而是修改配置，这样就增加了非常高的灵活性，也解耦了具体绑定。</p>
<p>Spring容器使用Bean的整体流程是：配置Bean--根据配置创建容器--通过容器获得并使用Bean，为此，需要先了解如何配置Bean。</p>
<p>所谓配置，就是一个配置文件，可以采取各种形式。Spring的具体配置形式有三种，一种是XML配置，一种是注解方式，还有一种是Java源代码模式，Spring in Action 4把注解方式也叫做隐式发现+自动装配机制。根据Spring in Action 4，最优先应当使用隐式发现+自动装配，其次是Java源代码配置方式，只有需要使用XML命名空间而无法用Java配置方式时，才需要用到XML，这三种模式都会学习到。</p>
<h2 style="text-align: center;">XML配置Bean</h2>
<p>XML方式下，先要在Spring的XML文件中配置Bean。Spring的XML配置文件一般叫做applicationContext.xml，而在Spring中提到applicationContext，指的就是Spring的核心容器。</p>
<p>applicationContext.xml文件长这个样子：</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?>
    &lt;beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

	
    &lt;!-- Define your beans here -->

    &lt;!-- define the dependency -->


&lt;/beans>
</pre>
<p>去掉XML的头部和beans标签中的一系列信息，我们需要做的是定义Bean和定义Bean的依赖关系。</p>
<p>在beans标签内部采用bean标签，配合一些属性来配置一个bean，来配置一下BaseballCoach这个类：</p>
<pre>
&lt;bean id="myCoach" class="iocdemo1.BaseballCoach">&lt;/bean> 
</pre>
<p>bean标签的id属性表示别名，可以理解为bean的变量名，class是需要加载的类的全称，用于通过反射寻找类并且加载。</p>
<p>配置好了第一个bean，现在来创建Spring容器，再次注意，ApplicationContext在Spring里指的就是Spring核心容器。</p>
<p>这个核心容器有几个根据不同的配置文件来加载的实现方式：</p>
<ol>
    <li>ClassPathXmlApplicationContext</li>
    <li>AnnotationConfigApplicationContext</li>
    <li>GenericWebApplicationContext</li>
    <li>Others..</li>
</ol>
<p>这些都会慢慢学到，现在把applicationContext.xml放到src的目录之下，然后使用ClassPathXmlApplicationContext，即直接从类目录下加载配置文件的方式创建容器，然后使用容器的getBean方式来获取Bean，修改MyApp.java的代码：</p>
<pre>
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyApp {
    public static void main(String[] args) {
        //创建容器
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        //获取Bean
        Coach theCoach = context.getBean("myCoach", Coach.class);
        //尝试使用Bean
        System.out.println(theCoach.getDailyWorkout());
        //关闭容器

    }
}
</pre>
<p>在创建容器的时候，由于applicationContext.xml就在src目录下，因此无需加具体路径。</p>
<p>获取bean的时候，采用了重载的方法，第一个参数是字符串形式的bean的名称，也就是bean的id属性值，第二个参数是所实现的接口的class类文件，所以获取Bean的类型也采用了Coach接口类型。</p>
<p>最后就是直接以多态的方式调用方法，来看看程序执行的结果：</p>
<pre>
三月 04, 2019 10:55:58 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3d71d552: startup date [Mon Mar 04 22:55:58 CST 2019]; root of context hierarchy
三月 04, 2019 10:55:58 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [applicationContext.xml]
I am BaseballCoach
</pre>
<p>一开始是Spring框架的启动和加载信息（之后省略），最后发现成功的调用了BaseballCoach的方法，然而这还不算完成了第一个Spring程序，但是不仅于此，如果此时我们需要使用TrackCoach，还需要修改MyApp.java吗？</p>
<p>完全不需要，只需在applicationContext.xml中修改一下bean的内容：</p>
<pre>
&lt;bean id="myCoach" class="iocdemo1.TrackCoach">&lt;/bean>
</pre>
<p>再次执行MyApp，就发现结果变成了：</p>
<pre>
I am TrackCoach
</pre>
<p>可见，Spring IOC神奇的无需修改MyApp.java代码，仅通过修改配置，就能够控制MyApp依赖于哪个对象，在这个简短的程序里，无论是接口还是两个实现都可以单独进行测试，而MyApp.java也可以通过不同的配置进行测试，无需修改源代码，这就是控制反转的例子，也是一般学习Spring的第一个程序。初次体验Bean之后，下一个就是依赖注入了。</p>

<h2 style="text-align: center;">XML配置构造器方式依赖注入</h2>














<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"
        integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
        crossorigin="anonymous"></script>
</body>
</html>