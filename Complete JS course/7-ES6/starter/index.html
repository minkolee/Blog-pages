<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Section 7: Get Ready for the Future: ES6 / ES2015</title>

    <style>
        .box {
            width: 200px;
            padding: 60px;
            text-align: center;
            font-size: 30px;
            margin-top: 50px;
        }

        .green {
            background-color: green;
        }

        .blue {
            background-color: dodgerblue;
        }

        .orange {
            background-color: orangered;
        }

    </style>

</head>

<body>
<h1>Section 7: Get Ready for the Future: ES6 / ES2015</h1>

<div class="box green">I'm green!</div>
<div class="box blue">I'm blue!</div>
<div class="box orange">I'm orange!</div>

<script>
    // var name5 = "Jane Smith";
    // var age5 = 23;
    // name5 = "Jane Miller";
    // console.log(name5);

    //const 常量,改变其值会报错
    // const  name6 = "Jane Smith";
    // name6 = "Jane Miller";
    // console.log(name6);


    //引用常量,其实是指针,指针地址不变,指向的对象的内容可以修改
    // const arr = [1,2,3,4];
    // arr.push(5);
    // console.log(arr);
    // arr = [];

    //var 在函数内部是函数环境, let 则是严格的块级作用域
    //var和let对于闭包不同效果,let变量无需再闭包闭进去,实际操作就行了


    //块级作用域不会影响外边的同级元素
    // let i =23;
    //
    // for(let i=0;i<5;i++){
    //     console.log(i);
    // }
    // console.log(i);


    // 新的BLock和IIFEs的方法

    // 使用花括号直接创建一个Block块区域或者说是IIFE,注意,这个不是创建对象
    // {
    //     const a = 1;
    //     let b = 2;
    //     var c = 3;
    // }
    //
    // console.log(a + b);
    // console.log(c)  //var根本无块级作用域可言,所以直接就泄露到了全局环境中,ES6中应该避免使用var

    // ES6中新的字符串方法

    // let firstName = "john";
    // let lastName = "Smith";
    // const yearOfBirth = 1990;
    // function calcAge(year) {
    //     return 2016-year;
    // }

    //ES6 字符串新方法
    // console.log(firstName.startsWith('J'));
    // console.log(firstName.endsWith('n'));
    // console.log(firstName.includes("oh"));
    // console.log(`${firstName}`.repeat(5));

    // ES6 箭头函数
    // const years = [1990, 1965, 1982, 1937];

    //ES5操作
    // var ages5 = years.map(function (el) {
    //     return 2016 - el;
    // });

    // console.log(ages5);

    // ES6匿名函数使用箭头函数

    // let ages6 = years.map(el => 2016 - el);
    // console.log(ages6);
    //
    // ages6 = years.map((el,index)=> `Age element ${index+1}:${2016-el}.`);
    // console.log(ages6);
    //
    // ages6 = years.map((el,index)=>{
    //     const now = new Date().getFullYear();
    //     const age = now - el;
    //     return `Age element ${index+1}:${age}.`
    // });
    // console.log(ages6);

    // ES6箭头函数最重要的是不会重新定义this属性
    // ES5

    // var box5 = {
    //     color: 'green',
    //     position: 1,
    //     clickMe: function () {
    //         document.querySelector(".green").addEventListener("click", function () {
    //             alert(this.color);
    //         })
    //     }
    // };
    // // 由于callback 函数不是由对象调用,所以this.color为undefined,无法显示
    // box5.clickMe();

    // ES6
    // let box6 = {
    //     color: 'green',
    //     position: 1,
    //     clickMe: function () {
    //         document.querySelector(".green").addEventListener("click", e => {
    //             alert(this.color);
    //         })
    //     }
    // };
    // box6.clickMe();

    // destructing 直接命名变量对应数组内元素,在函数形参中也可以使用
    //ES5
    // var john = ['john', 26];
    // var name = john[0];
    // var age = john[1];
    //
    // ES6
    // let john = ['john',26];
    //
    //
    // function show([name,age]) {
    //     console.log(name);
    //     console.log(age);
    // }
    //
    // show(john);
    //    还可以解构对象

    // const obj = {
    //     firstName: 'John',
    //     lastName: "Smith"
    // };

    // const {firstName,lastName} = obj;
    //
    // console.log(firstName);
    // console.log(lastName);

    // 解构实际的属性并赋予别名
    // const {firstName:a, lastName:b} = obj;
    //
    // console.log(a);//别名a对应firstName属性
    // console.log(b);
    // console.log(firstName);//此时这个不生效
    // console.log(lastName);//此时这个不生效

    // function calcAgeRetirement(year) {
    //     const age = new Date().getFullYear() - year;
    //     return [age,65-age]
    // }
    //
    // const [age,retirement] = calcAgeRetirement(1990);
    //
    // console.log(age);
    // console.log(retirement);

    // const boxes = document.querySelectorAll(".box");
    // console.log(boxes);

    // ES5
    // 转换为数组需要在boxes上调用slice方法
    // var boxesArr5 = Array.prototype.slice.call(boxes);
    // boxesArr5.forEach(function (cur) {
    //     cur.style.backgroundColor = "blue";
    // });

    // ES6
    // 新方法Array.from直接可以生成数组

    // const boxesArr6 = Array.from(boxes);
    // boxesArr6.forEach(cur => cur.style.backgroundColor="orange");

    // 遍历数组元素
    // ES5遍历数组并且操作元素通常使用for
    // for(var i = 0;i<boxesArr5.length;i++){
    //     if(boxesArr5[i].className ==="box blue"){
    //         continue;
    //     } else {
    //         boxesArr5[i].textContent='I am not blue.';
    //     }
    // }

    // ES6使用 for of 遍历数组元素
    // 遍历类名的时候可以考虑使用字符串新的includes方法
    // for(let element of boxesArr6){
    //     if(element.className.includes("blue")){
    //         element.textContent = 'I am blue also in ES6.';
    //     }
    // }

    // ES6中的indexof方法
    //ES5找到一个符合条件的数据所在的索引很麻烦
    // var ages = [12, 17, 8, 21, 24, 11];
    //
    // var full = ages.map(function (cur) {
    //     return cur>=18;
    // });
    // console.log(full);
    // console.log(full.indexOf(true));

    // ES6
    // let full = ages.findIndex(cur => cur >= 18);//找索引
    // console.log(full);
    //
    // let fullage = ages.find(cur=>cur>=18);
    // console.log(fullage)

    // ES6中的拆解数组的参数和使用,类似于python中的**kwargs
    // function addFourAges(a,b,c,d) {
    //     return a+b+c+d;
    // }
    //
    // var sum1 = addFourAges(10,20,30,36);
    // console.log(sum1);

    // ES5
    // var ages = [18,20,30,36];
    // var sum2 = addFourAges.apply(null,ages);//用apply调用,数组的元素会一一对应函数内arguments对象的位置
    // console.log(sum2);
    // ES6
    //在传参和拆解数组合并新数组的时候都可以使用,Python也可以.
    // let sum6 = addFourAges(...ages);
    // console.log(sum6)
    // 对于类似列表的组合比如选择器选出来的东西也适用
    // 与这个类似,用来将若干参数收集为一个数组的叫做 REST parameters

    //ES6 函数默认值
    //默认值自己已经搞定了,还写了一篇小文章

    //Maps ES6新增数据类型
    //ES5对象是一个散列表.但是对象的键只能是字符串,ES6新数据结构Map可以使用字符串以外的可哈希值作为键.
    // const question = new Map();
    // //使用set方法设置键值对
    // question.set('question', 'What is the official name of the latest major JavaScript version?');
    // question.set(1, 'ES5');
    // question.set(2, 'ES6');
    // question.set(3, 'ES2015');
    // question.set(4, 'ES7');
    // question.set("correct", 3);
    // question.set(true, 'Correct answer');
    // question.set(false, "Wrong, please try again!");
    // console.log(question);
    //
    // question.get('question');
    // question.delete(4);
    // question.has(4);//检查是否存在该键

    //回调函数传入的是先value后key
    // question.forEach((value, key) => {
    //     console.log(value);
    //     console.log(key);
    //
    // });
    //
    //
    // question.entries();//是一个键值对的迭代器,可以用for of 来遍历所有键值对
    //
    // for(let [key,value] of question.entries()){
    //     console.log(`${key}====${value}`)
    // }
    //要注意回调函数的键值顺序和这里相反
    //总结一下,这玩意其实就是Python的字典,原来的对象键值对比较简陋


    //class 类
    //ES6的类没有提供任何新的内容,仅仅是语法糖

    //ES5创建类
    //注意,构造函数里写方法,会将方法直接绑定到每个对象,开销太大,一定要绑定到原型上去
    var Person5 = function (name, year, job) {
        this.name = name;
        this.year = year;
        this.job = job;
    }

    Person5.prototype.showName = function () {
        console.log(this.name);
    }


    var john5 = new Person5("John", 1990, 'teacher');
    //
    // //ES6
    //
    // class Person6 {
    //     constructor(name, year, job) {
    //         this.name = name;
    //         this.year = year;
    //         this.job = job;
    //     }
    //     // 类方法直接使用方法名定义即可
    //     showName(){
    //         console.log(this.name);
    //     }
    //
    //     //ES6能够添加静态方法也就是类方法啦,和Python里的类方法是一样的,只能由类调用,而不是对象.
    //     static greeting(){
    //         console.log("Hey there!")
    //     }
    // }
    //
    // var john6 = new Person5("John", 1990, 'teacher');
    // // 使用class会将方法绑定到原型上,因此class 就是ES5对象的语法糖,没有任何新增内容

    // 类的继承
    //ES5需要在子类的构造函数内调用父类的构造函数,而且是以.call方式调用,这样就是以当前的对象设置属性.然后再把新增的属性设置上.
    //然后再把子类的prototype指向父类的prototype,就完成了基于原型链的继承


</script>
</body>
</html>