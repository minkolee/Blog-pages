<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Section 7: Get Ready for the Future: ES6 / ES2015</title>

    <style>
        .box {
            width: 200px;
            padding: 60px;
            text-align: center;
            font-size: 30px;
            margin-top: 50px;
        }

        .green {
            background-color: green;
        }

        .blue {
            background-color: dodgerblue;
        }

        .orange {
            background-color: orangered;
        }

    </style>

</head>

<body>
<h1>Section 7: Get Ready for the Future: ES6 / ES2015</h1>

<div class="box green">I'm green!</div>
<div class="box blue">I'm blue!</div>
<div class="box orange">I'm orange!</div>

<script>
    // var name5 = "Jane Smith";
    // var age5 = 23;
    // name5 = "Jane Miller";
    // console.log(name5);

    //const 常量,改变其值会报错
    // const  name6 = "Jane Smith";
    // name6 = "Jane Miller";
    // console.log(name6);


    //引用常量,其实是指针,指针地址不变,指向的对象的内容可以修改
    // const arr = [1,2,3,4];
    // arr.push(5);
    // console.log(arr);
    // arr = [];

    //var 在函数内部是函数环境, let 则是严格的块级作用域
    //var和let对于闭包不同效果,let变量无需再闭包闭进去,实际操作就行了


    //块级作用域不会影响外边的同级元素
    // let i =23;
    //
    // for(let i=0;i<5;i++){
    //     console.log(i);
    // }
    // console.log(i);


    // 新的BLock和IIFEs的方法

    // 使用花括号直接创建一个Block块区域或者说是IIFE,注意,这个不是创建对象
    // {
    //     const a = 1;
    //     let b = 2;
    //     var c = 3;
    // }
    //
    // console.log(a + b);
    // console.log(c)  //var根本无块级作用域可言,所以直接就泄露到了全局环境中,ES6中应该避免使用var

    // ES6中新的字符串方法

    // let firstName = "john";
    // let lastName = "Smith";
    // const yearOfBirth = 1990;
    // function calcAge(year) {
    //     return 2016-year;
    // }

    //ES6 字符串新方法
    // console.log(firstName.startsWith('J'));
    // console.log(firstName.endsWith('n'));
    // console.log(firstName.includes("oh"));
    // console.log(`${firstName}`.repeat(5));

    // ES6 箭头函数
    // const years = [1990, 1965, 1982, 1937];

    //ES5操作
    // var ages5 = years.map(function (el) {
    //     return 2016 - el;
    // });

    // console.log(ages5);

    // ES6匿名函数使用箭头函数

    // let ages6 = years.map(el => 2016 - el);
    // console.log(ages6);
    //
    // ages6 = years.map((el,index)=> `Age element ${index+1}:${2016-el}.`);
    // console.log(ages6);
    //
    // ages6 = years.map((el,index)=>{
    //     const now = new Date().getFullYear();
    //     const age = now - el;
    //     return `Age element ${index+1}:${age}.`
    // });
    // console.log(ages6);

    // ES6箭头函数最重要的是不会重新定义this属性
    // ES5

    // var box5 = {
    //     color: 'green',
    //     position: 1,
    //     clickMe: function () {
    //         document.querySelector(".green").addEventListener("click", function () {
    //             alert(this.color);
    //         })
    //     }
    // };
    // // 由于callback 函数不是由对象调用,所以this.color为undefined,无法显示
    // box5.clickMe();

    // ES6
    // let box6 = {
    //     color: 'green',
    //     position: 1,
    //     clickMe: function () {
    //         document.querySelector(".green").addEventListener("click", e => {
    //             alert(this.color);
    //         })
    //     }
    // };
    // box6.clickMe();

    // destructing 直接命名变量对应数组内元素,在函数形参中也可以使用
    //ES5
    // var john = ['john', 26];
    // var name = john[0];
    // var age = john[1];
    //
    // ES6
    // let john = ['john',26];
    //
    //
    // function show([name,age]) {
    //     console.log(name);
    //     console.log(age);
    // }
    //
    // show(john);
    //    还可以解构对象

    // const obj = {
    //     firstName: 'John',
    //     lastName: "Smith"
    // };

    // const {firstName,lastName} = obj;
    //
    // console.log(firstName);
    // console.log(lastName);

    // 解构实际的属性并赋予别名
    // const {firstName:a, lastName:b} = obj;
    //
    // console.log(a);//别名a对应firstName属性
    // console.log(b);
    // console.log(firstName);//此时这个不生效
    // console.log(lastName);//此时这个不生效

    function calcAgeRetirement(year) {
        const age = new Date().getFullYear() - year;
        return [age,65-age]
    }

    const [age,retirement] = calcAgeRetirement(1990);

    console.log(age);
    console.log(retirement);












</script>
</body>
</html>