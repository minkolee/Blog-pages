<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>Hibernate 01 域模型与元数据</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<p>上一篇的破冰之旅中的最大收获是发现JPA和Hibernate都可以自行创建数据库, 而不用先行创建, 果然爽.</p>
<p>不过例子实在太简单, 这一章是来看看Domain model 和 metadata. 然后创建一个更复杂的数据库来操作.</p>

<ol>
    <li><a href="#con1">Domain Model</a></li>
    <li><a href="#con2">CaveatEmptor系统</a></li>
    <li><a href="#con3">创建可持久化的类</a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>
<h2 style="text-align: center;" id="con1">Domain Model</h2>
<p>在一个系统中, Entity用来称呼一个系统中被广为接受的各种概念, 对于一个电商系统来说, 可能会有付款, 订单, 客户, 商品等. 可以看到, 这些概念主要基于商业模型.</p>
<p>基于商业模型, 系统设计师们会设计出一个面向对象的模型, 这个模型依然是概念上的(即不是用某种具体的编程语言写出来的), UML类图就是典型的面向对象的模型的代表.</p>
<p>将这个面向对象的模型中代表Entity的部分, 以及表示Entity之间的关系抽出来, 就组成了 Domain Model, Domain Model实际上是现实世界的抽象.</p>

<h2 style="text-align: center;" id="con2">CaveatEmptor UML类图</h2>
<p>例子的数据库就是用于一个CaveatEmptor网站, 这个网站是一个拍卖网站, 采用英式拍卖方式, 即竞拍者可以不断出价, 直到竞拍期结束, 出价最高的人会赢得竞标. 每个商品仅仅会被拍卖一次.</p>
<p>拍卖的商品被分为大类, 然后相似的商品存放在同一个区域和货架上. 拍卖网站会提供分层次的目录以让竞拍者可以浏览商品或者搜索.</p>
<p>选择一个商品之后, 就会跳转到商品详情页, 可以查看商品的图片等信息. </p>
<p>一次拍卖包含一系列的出价, 其中一个是赢得竞标的出价. 竞标人的信息包括姓名, 地址, 付款信息.</p>
<p>通过这些分析, 就可以组织出一个UML图:</p>
<img src="http://img.conyli.cc/blogs/caveatemptoruml.jpg" alt="UML类图">
<p>由于一个商品就被拍卖一次, 因此无需单独设置ITEM(表示商品)和AUCTION(表示一次拍卖)两个对象, 仅仅用一个ITEM就可以.</p>
<p>有了ITEM对象后, 很显然, ITEM要属于一个CATEGORY, 一个CATEGORY之下可以没有商品. 此外表示每一次出价的BID显然需要和ITEM关联, 一个ITEM可能有多个出价, 也可能没有出价. 一个BID必然要与一个ITEM关联.</p>
<p>IMAGE也与ITEM有关联, 一个ITEM可能没有也可能有图片, 一个图片对象则一定对应一个ITEM. 所以ITEM 与 BID IMAGE都是组合关系.</p>
<p>CATEGORY比较有意思, 这个UML类图的0..*表示一个CATEGORY最多从属于另外一个CATOGORY, 一个CATEGORY可以有多个子CATEGORY.</p>
<p>USER和BID, USER和ITEM, USER和BillingDetails之间都是0..*的关系, 即一个用户有0到多个BID, ITEM和付款信息, USER和Address是组合关系, 即用户肯定有Address信息.</p>
<p>CreditCard类和BankAccount类继承自BillingDetails类.</p>
<p>这个UML类图是只描述了所有要进行持久化的类, 而且也省略了这些类的方法, 仅关注成员变量, 也就是会被持久化的内容.</p>

<h2 style="text-align: center;" id="con3">创建可持久化的类 - 访问成员变量的方法</h2>
<p>接下来的一个关键工作, 就是如何根据UML类图, 创建可以持久化的类.</p>
<p>需要用一个POJO类型的Java Bean类来作为持久化类的基础, 还需要满足如下条件:</p>
<ol>
    <li>可以没有get set方法, 可以将Hibernate配置成直接存取字段或者通过方法存取. </li>
    <li>不能是内部类</li>
    <li>类本身和所有方法都不能是final, 这是JPA标准的要求.</li>
    <li>JPA和Hibernate都要求必须有一个至少有包可见权限的无参构造器, JavaBean无此要求.</li>
    <li>与UML类图中规定的成员变量相同</li>
</ol>
<p>此外, 还有一些特殊的问题需要解决. 一个一个来看. 首先就是Hibernate通过成员变量还是get方法进行操作的问题.</p>
<p>Java的get和set方法(private权限的成员变量+public权限的set/get方法), 实际上提供的是一个隔离, 即可以改变类内部的实现, 而不更改接口. 实际上, 即使没有直接对应set/get方法的成员变量也没有关系.</p>
<p>将Hibernate配置为直接通过反射存取成员变量的时候, 没有问题. 配置成通过get方法访问成员变量的时候, 类内部实际的实现可能与对应的数据库表设计相互分离 - 即没有关系.</p>
<p>看下边这个例子:</p>
<pre>
public class User {

    protected String firstname;
    protected String lastname;

    public String getName() {
        return firstname + ' ' + lastname;
    }

    public void setName(String name) {
        StringTokenizer t = new StringTokenizer(name);
        firstname = t.nextToken();
        lastname = t.nextToken();
    }
}
</pre>
<P>如果数据库中有name列, 就可以添加这个方法, 但实际的User类并没有该成员变量. 这里经我测试, 在getName上添加注解, 自动生成表的时候不会生成该字段, 还是需要有Name成员变量才行.</P>
<p>这里还一个坑就是如果User类不指定表名, 则User是一个关键字, SQL语句会执行出错.</p>
<p>如果都使用默认的@Id和@GeneratedValue, Hibernate创建的序列对象相同, 如果更新两个类, 都会使用同一个序列对象, 可以具体配置不同的序列对象.</p>
<p>还有就是JPA启动的时候删除表和重新创建表并不在事务管理范围内, 所以会变成每行语句直接提交.</p>

<h2 style="text-align: center;" id="con4">创建可持久化的类 - dirtycheck</h2>


























<h2 style="text-align: center;" id="con5"></h2>
<h2 style="text-align: center;" id="con6"></h2>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
