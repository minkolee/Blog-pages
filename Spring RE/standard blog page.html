<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>Spring RE 01 IOC容器</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<p>IOC容器实际上就是一个强化版的工厂, 在启动容器的时候根据配置来创建好所有的Bean, 然后向工厂就可以获取这些Bean来进行使用.</p>
<p>在最早接触Spring的时候, 就听到说这个框架不仅仅可以用于Web应用, 但当时只是按部就班的学习如何编写Web程序, 对于Java的理解也不够深.</p>
<p>现在终于明白了这个东西的本质就是容器, 容器可以单独被外部使用, 而套上了Servlet的外皮, 和ServletContext互相引用之后, 就成了Web应用的框架.</p>
<p>关于依赖注入的几种方式比如构造器注入, setter方法注入, 这不是属于Spring 特有的内容, 这次RE就要来深入看看Spring的东西.</p>


<ol>
    <li><a href="#con1">Resource接口</a></li>
    <li><a href="#con2"></a></li>
    <li><a href="#con3"></a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>
<h2 style="text-align: center;" id="con1">Resource接口</h2>
<p>Resource接口是Spring提供的, 访问一切资源的抽象接口. 有很多具体实现类. 这些类是按照所加载的资源的不同类型来区分的, 有些加载二进制数据, 有些加载文件, 有些加载URL对应的资源.</p>
<p>实际上可以Resource接口对于Spring的意义就好比File对于Java的意义, 都是提供了可供操作的资源的一种抽象.</p>
<p>在使用这些接口的具体实现类的时候, 根据要加载的资源不同, 可以使用不同的方式. 这里我在IDEA里直接选创建Spring项目(但不要选JavaEE-Web)项目, IDEA会自动创建一个项目并在lib中下载好Spring 4.3.18 的一系列包.</p>
<p>然后可以尝试来使用各种Resource类型:</p>
<pre>
package cc.conyli;

import org.springframework.core.io.*;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.util.FileCopyUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class ResourceLearn {

    public static void main(String[] args) throws IOException {

        //本地文件系统加载
        FileSystemResource resource1 = new FileSystemResource("D:\\test.txt");

        if (resource1.exists()) {
            //可以获取文件名和长度
            System.out.println(resource1.getFilename() + "的字节数是" + resource1.contentLength());

            //可以获取输入流
            InputStream in = resource1.getInputStream();
            //可以获取输出流, 因为FileSystemResource实现了WritableResource这个接口
            //实现这个接口的有 FileSystemResource, FileUrlResource, PathResource, 注意, 如果使用Resource类型则无法多态调用这个getOutPutStream()方法
            OutputStream out = resource1.getOutputStream();
            //可以获取File对象, 不过注意, 如果查找的文件实际上位于一个jar包中, 则getFile()会报异常, 因为不存在文件系统中的对应文件, 要读取该文件改用getInputStream打开输入流即可
            File textTxt = resource1.getFile();
            //可以在资源的相对地址上创建新文件
            Resource newFile = resource1.createRelative("text2.text");

        }

        //类路径加载, 所谓类路径, 就是寻找类的路径, 在WEB应用下是/lib和/WEB-INF/classes作为类路径, 而在普通程序里, 编译的程序包根目录就是类路径
        // 由于不是web应用, 在 src下创建一个 test2.html, 使用类路径加载器, 此时要用相对classpath的相对路径来写
        Resource resource2 = new ClassPathResource("test2.html");

        if (resource2.exists()) {
            System.out.println(resource2.getFilename() + "的字节数是" + resource2.contentLength());
            //也可以获取input, 无法获取output
            InputStream in2 = resource2.getInputStream();
            //也可以获取File对象
            File test2HTML = resource2.getFile();
            //还可以通过装饰器来指定编码, 这个装饰器可以直接获取字符流
            EncodedResource encodedResource = new EncodedResource(resource2, StandardCharsets.UTF_8);
            //FileCopyUtil是org.springframework.util提供的工具, 看来这个工具包也有不少东西可以用
            String content = FileCopyUtils.copyToString(encodedResource.getReader());
            System.out.println(content);

        }

        //还可以引用URL网络资源
        Resource resource3 = new UrlResource("https://conyli.cc");
        if (resource3.exists()) {
            System.out.println(resource3.getURI());
        }

    }
}
</pre>
<p>如果对于具体的类很了解, 是可以直接使用对应类的. 后来根据新加的Path类带来的PathResource类可以打开URL和本地文件资源. 但还是有点烦, 有没有一种更统一的只使用一个类加载文件呢. 答案是有的.</p>
<p>在了解统一的加载方式之前先来看两种简化方式, 第一种是资源地址表达式, 第二种是Ant风格通配符:</p>
<ol>
    <li>资源地址表达式
    <ol>
        <li><code>classpath:</code>, 从类路径中加载</li>
        <li><code>classpath*:</code>, 从类路径中加载, 扫描全部的相同的路径和包内路径</li>
        <li><code>file:</code>, 从文件系统中加载,其后可以跟相对或者绝对路径</li>
        <li><code>http:</code>, 从网络加载</li>
        <li><code>ftp:</code>, 从ftp加载</li>
        <li><code>无前缀</code>, 根据具体的ApplicationContext而定</li>
    </ol></li>
    <li>Ant风格资源地址
        <ol>
            <li><code>?</code>, 匹配一个字符</li>
            <li><code>*</code>, 匹配任意字符</li>
            <li><code>**</code>, 匹配任意多层路径</li>
        </ol>
    </li>
</ol>
<p>统一加载资源的接口叫做ResourceLoader, 在此基础上又扩展一个接口叫做ResourcePatternResolver, 听名字就知道可以根据字符形式的路径解析, 实现类是在此基础上的PathMatchingResourcePatternResolver</p>
<p>前两个接口的区别是, ResourceLoader只能使用资源地址表达式, ResourcePatternResolver可以使用资源地址表达式加上Ant通配符. 针对上边的例子, 修改如下:</p>
<pre>

</pre>









<h2 style="text-align: center;" id="con2"></h2>
<h2 style="text-align: center;" id="con3"></h2>
<h2 style="text-align: center;" id="con4"></h2>
<h2 style="text-align: center;" id="con5"></h2>
<h2 style="text-align: center;" id="con6"></h2>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
