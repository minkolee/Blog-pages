<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>Java 数据结构 包 - 栈</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 60px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<p>要敲代码, 设计先行. 栈不再解释了, 这里主要看设计思想</p>
<p>看来修炼完数据结构与算法之后, 可以左手一把精钢哈希表盾牌, 右手一条链表数组剑鞭, 可以去刷怪(题)了.</p>

<ol>
    <li><a href="#con1">栈的设计</a></li>
    <li><a href="#con2">编写add方法</a></li>
    <li><a href="#con3">栈的应用 - 括号匹配</a></li>
    <li><a href="#con4">栈的应用 - 表达式转换</a></li>
    <li><a href="#con5">remove系列方法</a></li>
    <li><a href="#con6">链表实现包的优缺点</a></li>
    <li><a href="#con7">练习</a></li>
</ol>

<h2 style="text-align: center;" id="con1">栈的设计</h2>
<p>栈顶: 最后添加到栈的一项. 栈限制对其中项目的访问, 客户只能看到或删除栈顶或者加入栈顶. 查找的方法是一个个删除, 直到找到或者为空.</p>
<p>栈的这个特点, 可以将一系列内容的顺序反过来.</p>
<p>将项添加到栈中的操作称为入栈(push), 删除操作称为出栈(pop). 获取栈顶项目但不删除的操作叫做查看(peek). 一般不能在栈中查找具体项, 但可以根据实现而不同.</p>
<p>所以老样子, 先来创建接口:</p>
<pre>
public interface Stack&lt;T> {

    void push(T newEntry);

    T pop();

    T peek();

    boolean isEmpty();

    void clear();
}
</pre>
<p>接口只是一个开始, 然后还需要规划行为:</p>
<ol>
    <li>栈为空时候要不要抛异常. 取决于是否认为栈中可以存放null. 如果可以, 最好的方法是在栈空的时候, 对公共方法比如pop()和peek()来抛出异常.</li>
    <li>私有方法与公有方法不同, 私有方法需要处理各种可能出现的问题, 以让私有方法可以信任. 不要信任公有方法, 客户会以很多方式来调用.</li>
    <li>抛异常抛什么异常呢, 如果预期让客户从异常中恢复, 就应该抛受检异常. 对于栈来说, 如果栈为空一般意味着使用错误, 所以要抛运行时错误.</li>
</ol>

<h2 style="text-align: center;" id="con2">栈的实现</h2>
<p>回想一下之前写的包, 虽然包本身是没有顺序的. 但是我们内部使用的链表和数组都是有顺序的.</p>
<p>但具体顺序如何, 还需要进一步看实现, 数组包添加到最后一项, 默认弹出最后一项, 其实完全符合要求. 链表每次添加在头部节点, 删除的时候也从头部节点开始删除, 依然符合这种情况.</p>
<p>所以可以任意选择数组和链表结构来实现, 但是对外暴露的API就不要向包那么多了, 仅需要实现上边的代码.</p>
<p>就以链表为例, 修改一个栈出来, 由于栈对外暴露的方法不多, 因此只需要弄两个私有方法来添加和删除首结点即可:</p>
<pre>
public class LinkedListStack&lt;T> implements Stack&lt;T> {

    private class Node {
        private T data;
        private Node next;

        private Node(T dataPortion) {
            this(dataPortion, null);
        }

        private Node(T dataPortion, Node nextNode) {
            this.data = dataPortion;
            this.next = nextNode;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "data=" + data +
                    '}';
        }
    }

    private Node firstNode;
    private int numberOfEntries;

    public LinkedListStack() {
        this.firstNode = null;
        this.numberOfEntries = 0;
    }


    @Override
    public T pop() {
        return remove();
    }

    @Override
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空, 不能进行peek()操作");
        } else {
            return firstNode.data;
        }
    }

    @Override
    public boolean isEmpty() {
        return numberOfEntries == 0;
    }

    @Override
    public void clear() {
        firstNode = null;
        numberOfEntries = 0;
    }

    @SuppressWarnings("unchecked")
    public T[] toArray() {
        T[] result = (T[]) new Object[numberOfEntries];
        int i = 0;
        Node currentNode = firstNode;
        while (i &lt; numberOfEntries && currentNode != null) {
            result[i++] = currentNode.data;
            currentNode = currentNode.next;
        }
        return result;
    }

    @Override
    public void push(T newEntry) {
        add(newEntry);
    }

    /**
     * 私有方法删除并返回一个数据, 删除链表开头的数据
     * 如果链表为空则抛出异常
     *
     * @return 当链表为空返回null, 不为空则返回链表第一个节点的数据对象
     */
    private T remove() {
        T result = null;
        if (!isEmpty()) {
            result = firstNode.data;
            firstNode = firstNode.next;
            numberOfEntries--;
        } else {
            throw new RuntimeException("栈为空, 不能进行pop()操作");
        }
        return result;
    }

    /**
     * 向链表中添加一个新的数据, 原理是创建一个新节点, 让新节点指向链表头, 然后让链表头指向新节点
     *
     * @param newEntry The object to be added as a new entry.
     */
    private void add(T newEntry) {
        Node newNode = new Node(newEntry);
        newNode.next = firstNode;
        firstNode = newNode;
        numberOfEntries++;
    }
}
</pre>

<h2 style="text-align: center;" id="con3">栈的应用 - 表达式处理</h2>
<p>先看几个概念:</p>
<ol>
    <li>a+b 中缀表达式, 即运算符在操作数之间.</li>
    <li>+ab 前缀表达式, 也叫波兰表示法</li>
    <li>ab+ 后缀表达式, 也叫逆波兰表示法</li>
</ol>
<p>利用栈首先可以解决的一大问题, 就是中缀代数表达式中的分隔符是否正确, 分隔符即{},[],(), 所谓分隔符正确, 就是指整个式子中所有的分隔符都是能够互相配对的.</p>
<p>这个套路其实之前就玩过了, 如果表达式是一个字符串, 只要按从左到右(或者右到左)的顺序扫描一遍, 将所有的一侧符号都压入栈中, 扫描到另外一侧符号的时候, 从栈中弹出与其对应的符号, 如果扫描完毕, 栈依然是空的, 就说明分隔符是正确的.</p>
<p>写出代码如下:</p>
<pre>
public boolean checkBalance(String expression) {
    boolean result = false;
    if (expression == null) {
        return result;
    }

    int length = expression.length();
    LinkedListStack&lt;Character> stack = new LinkedListStack&lt;>();
    Character popedCharacter;
    for (int i = 0; i &lt; length; i++) {
        char c = expression.charAt(i);

        switch (c) {
            case '{':
            case '[':
            case '(':
                stack.push(c);
                break;
            case '}':
                popedCharacter = stack.pop();
                if (popedCharacter != '{') {
                    return result;
                }
                break;
            case ']':
                popedCharacter = stack.pop();
                if (popedCharacter != '[') {
                    return result;
                }
                break;
            case ')':
                popedCharacter = stack.pop();
                if (popedCharacter != '(') {
                    return result;
                }
                break;
            default:
        }

        System.out.println("当前的栈是: " + Arrays.toString(stack.toArray()));
    }
    if (stack.isEmpty()) {
        result = true;
    }

    return result;
}
</pre>

<h2 style="text-align: center;" id="con4">栈的应用 - 表达式转换</h2>
<p>将中缀表达式转换成后缀表达式. 当时第一次碰到这个算法的时候还是仔细想了一下. 因为后缀表达式是按照优先级来排序的, 优先级高的会拍在一起, 所以这个套路就是不断的比较压入栈的操作符与当前操作符的优先级.</p>
<p>如果当前操作符的优先级高于栈中的操作符,就说明这个当前操作符一定是写的更靠左, 所以就压入栈中, 等到下一个操作数拼接到字符串上之后, 再弹栈或者进行比较, 如果小于, 就说明靠右, 就出一个栈, 然后把当前操作符压进栈, 然后继续拼接字符串并进行比较.</p>
<p>总结一下操作就是:</p>
<ol>
    <li>从左至右扫描操作符, 创建一个新的空字符串A作为结果</li>
    <li>对于每一个符号, 如果不是运算符, 拼接到A上</li>
    <li>对于每一个符号, 如果是运算符, 如果栈为空, 压入栈中. 如果栈不为空, 比较当前符号与栈顶符号的优先级程度</li>
    <li>当前符号优先级大于栈顶符号, 将当前符号压入栈中</li>
    <li>当前符号优先级等于或者小于栈顶符号, 说明之前有操作符不属于下一个操作数, 必须反复弹出操作符并拼接到字符串上, 直到栈为空, 说明之前的操作符都已经弹完了, 之后再把当前操作符加入到栈中.</li>
</ol>
<p>根据这个方法, 写出支持四则运算, 不带括号的方法:</p>
<pre>
public String change(String expression) {
    if (expression == null) {
        return "";
    }
    LinkedListStack&lt;Character> stack = new LinkedListStack&lt;>();
    StringBuilder stringBuilder = new StringBuilder();
    int length = expression.length();
    for (int i = 0; i &lt; length; i++) {
        char c = expression.charAt(i);

        switch (c) {
            case '+':
            case '-':
            case '*':
            case '/':
                if (stack.isEmpty()) {
                    stack.push(c);
                } else {
                    //当前优先级大于栈中的, 说明上一个操作数不是上一个操作符的操作数, 所以将运算符入栈
                    if (big(c, stack.peek())) {
                        stack.push(c);
                    } else {
                        //如果当前优先级小于等于, 说明存在之前要计算完毕的表达式, 就需要反复弹出, 直到栈为空或者再出现大于的情况
                        while (!stack.isEmpty() && !big(c, stack.peek())) {
                            stringBuilder.append(stack.pop());
                        }
                        //弹干净之后说明又有一段新的表达式, 加入栈中
                        stack.push(c);
                    }
                }
                break;
            default:
                stringBuilder.append(c);
                break;
        }
    }
    //全部处理完之后, 如果还有栈中的运算符, 一定是前边剩下的, 也全部弹出加在字符串后边即可.
    while (!stack.isEmpty()) {
        stringBuilder.append(stack.pop());
    }

    return stringBuilder.toString();

}

//第一个操作符的优先级大于第二个操作符
private boolean big(Character c1, Character c2) {
    return (c1 == '*' || c1 == '/') && (c2 == '+' || c2 == '-');
}
</pre>
<p>逻辑还是对的, 像<code>System.out.println(test.change("a*b*c-d*e"));</code>, 运算结果是: ab*c*de*-, 按照结合律ab=y, 这个式子是 yc*de*, yc=x, 变成 xde*-, 这个时候就是运算 de*=z, 最后就是 xz-, 正确.</p>










<h2 style="text-align: center;" id="con5">栈的设计</h2>
<h2 style="text-align: center;" id="con6">栈的设计</h2>






<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
