<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第四章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第六章 存储器体系</h1>

<ol>
    <li><a href="#con1">存储器简介</a></li>
    <li><a href="#con2">局部性</a></li>
    <li><a href="#con3">高速缓存</a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>

<h2 style="text-align: center;" id="con1">存储器简介</h2>
<h3>练习 6.2 计算一个磁盘的容量</h3>
<p>磁盘容量 = 2 盘片 * 2面 * 10000个柱面=磁道 * 400个扇区 * 512个字节 = 8192000000, 换算成M 大概是 8192000000/1000/1000 = 8192M 大小, 大概是8GB大小.</p>
<h3>练习 6.3 计算扇区的访问时间</h3>
<p>平均旋转时间 = 60s/15000RPM/2 = 0.002秒</p>
<p>平均传送时间 = 60s/15000RPM * 1/500平均扇区数 = 0.000008 秒, 寻道时间为8ms, 加起来就是 0.002+0.008+0.000008 = 0.010008秒, 几乎就是10ms</p>
<h3>练习 6.4 计算1MB文件的访问时间</h3>
<p>这个文件需要的2000个扇区来存储, 正好是1000个扇区的一倍</p>
<p>平均旋转时间 = 60s/10000/2 = 3ms</p>
<p>最好的情况是, 定位到扇区之后, 旋转两圈正好读完, 总时间是 3ms+5ms+ 转两圈的时间 60/10000*2 = 20ms</p>
<p>如果每一个块都不连续, 则读完一个之后还需要读另外一个, 由于读每个块的时间可以忽略不计, 因此总时间是 (3ms+5ms)*2000 = 16秒</p>
<h3>练习 6.5 估算SSD的寿命</h3>
<p>以470MB/S写, 时间是 128e15/470*1024*1024 = 259724069秒, 换算成年是 8.2 年</p>
<p>以303MB/S的速度写, 时间是 128e15/303/1024/1024/86400/365 = 12.77 年</p>
<p>以20GB每天的速度写: 时间是 128e15/(20*1024*1024*1024*1024)/365 = 15.94 年</p>

<h2 style="text-align: center;" id="con2">局部性</h2>
<p>所谓局部性, 有两种局部性, 空间的局部性和时间的局部性.</p>
<p>空间的局部性, 指的就是程序会不断的引用相近的内存空间. 时间的局部性, 指的是不久的将来, 程序还会多次引用一个内存空间.</p>
<p>简单的说, 空间局部性指的是访问一批相近的元素, 时间局部性指的是反复访问同一个元素. 所以标量没有空间局部性.</p>
<ol>
    <li>重复引用相同变量的程序具有良好的时间局部性</li>
    <li>步长为k的程序, 步长越小, 空间局部性越好. 在内存中大步长跳来跳去的程序空间局部性很差</li>
    <li>对于取指令来说, 循环体越小, 循环次数越多, 局部性越好</li>
</ol>
<h3>练习 6.7 改变循环顺序, 以步长1遍历三维数组</h3>
<p>由于三维数组最右边的数字变化最频繁, 所以需要重新排列三个循环变量的位置, 改写如下:</p>
<pre>
int sumarary3d(int a[N][N][N]) {
    int i, j, k, sum = 0;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            for (k = 0; k < N; k++) {
                sum += a[i][j][k];
            }
        }
    }
    return sum;
}
</pre>
<h3>练习 6.8 检查函数的空间局部性</h3>
<p>p是一个point类型的数组, 长度1000. point 是一个结构, 包含2个 3个的int数组. 很显然, 在内存中的存放顺序实际上是一个vel, 一个acc这么一直存放下去的.</p>
<ol>
    <li>看第一个函数, 其实际上的操作顺序, 是从数组开始然后按照顺序开始一个一个的写成0, 因此空间局部性比较好.</li>
    <li>第二个函数, 是按照每隔3个元素操作一个结构, 再跳到下一个结构开始间隔三个来操作.</li>
    <li>第三个函数的跨度就更大了, 是先间隔整个struct长度, 修改三个循环. </li>
</ol>
<p>所以从空间局部性上来排列的话, 第一个函数空间局部性最好, 第二个次之, 第三个函数空间局部性最差.</p>


<h2 style="text-align: center;" id="con3"></h2>
<p>高速缓存的结构如下:</p>
<p>如果一共有2的m次方个地址的话, 可以用S长度的一个数组来表示缓存组. 每个组里有E行.</p>
<p>每一行里有1个有效位, m-(b+s)个标记位, 以及B = 2的b次方的字节的高速缓存块.</p>
<p>很显然, 一组E行的高速缓存容量就是E x B, 而全部的缓存大小就是 E x B x S.</p>
<p>如何判断高速缓存中是否存着对应整个机器的某个地址位的元素, 实际上就是把m的地址为翻译成为高速缓存的地址.</p>
<p>简单的说, 就是把地址m(一串二进制位)分成三段, 中间的一段对应数组S的索引, 前边的一段对应标记位, 最后一段对应块的偏移. 这样就可以从高速缓存中取出对应的内容.</p>
<h3>练习6.9 高速缓存的参数计算</h3>
<table>
    <thead>
    <tr>
        <th>高速缓存</th>
        <th>m</th>
        <th>C</th>
        <th>B</th>
        <th>E</th>
        <th>S</th>
        <th>t</th>
        <th>s</th>
        <th>b</th>
    </tr>
    </thead>
    <tr>
        <td>1</td>
        <td>32</td>
        <td>1024</td>
        <td>4</td>
        <td>1</td>
        <td>256</td>
        <td>22</td>
        <td>8</td>
        <td>2</td>
    </tr>
    解释: 主存的存储器地址有32位, 所以一共有2的32次方个地址. 由于C= S*E*B, 可以先计算出来S= 1024/4/1 =
    <tr>
        <td>2</td>
        <td>32</td>
        <td>1024</td>
        <td>8</td>
        <td>4</td>
        <td>32</td>
        <td>24</td>
        <td>5</td>
        <td>3</td>
    </tr>
    <tr>
        <td>3</td>
        <td>32</td>
        <td>1024</td>
        <td>32</td>
        <td>32</td>
        <td>1</td>
        <td>27</td>
        <td>0</td>
        <td>5</td>
    </tr>
</table>
<p>简单的说, 其实就是将内存通过标记和组索引进行了分块, 然后对应到高速缓存的每个块上, 当然, 高速缓存的块数量是肯定没有内存多的. 可以认为高速缓存中始终存放着一部分内存中的数据.</p>
<p>通过6-30的图, 可以知道内存的多个块, 对应高速缓存中的同一个S组的索引, 这就是高速缓存的原理.</p>


<h2 style="text-align: center;" id="con4"></h2>

<h2 style="text-align: center;" id="con5"></h2>

<h2 style="text-align: center;" id="con6"></h2>

























<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
