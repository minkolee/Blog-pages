<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第四章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第七章 链接</h1>
<p>进入全书的第二部分了, 之前想都没想过, 能一路读下来还都懂了. 第一部分讲的实际上是程序和硬件之间的关系, 第二部分讲的是程序和操作系统之间的关系.</p>

<ol>
    <li><a href="#con1">什么是链接</a></li>
    <li><a href="#con2">编译和链接</a></li>
    <li><a href="#con3"></a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>

<h2 style="text-align: center;" id="con1">什么是链接</h2>
<p>链接指的是将程序和数据片段收集并组合在一起成为一个单一文件的过程. 这个文件是可执行文件, 可以被加载到内存中并执行. 链接可以在编译时(源代码被翻译成机器代码), 加载时(被加载器加载到内存中), 或者运行时来进行.</p>
<p>执行链接动作的程序叫做链接器.</p>
<p>有两个小例子程序文件, 分别叫做 main.c 和 sum.c: </p>
<pre>
//main.c
int sum(int *a, int n);

int array[2] = {1,2};

int main(){
    int val = sum(array, 2);
    return val;
}
</pre>
<pre>
//sum.c
int sum(int *a, int n){
    int i, s = 0;
    for(i = 0; i < n; i++){
        s += a[i];
    }
}
</pre>
<p>这两个程序很简单, 在main 中声明了一个函数原型 sum, 而sum.c就是这个函数所在的文件. 下边就要对其进行编译和链接.</p>
<p>大多数的编译器驱动程序(编译器)并不是仅仅翻译源代码, 而是预处理器, 编译器, 汇编器和链接器的组合.</p>
<p>将两个文件放到同一个目录之下, 然后执行 <kbd>gcc -Og -o prog main.c sum.c</kbd></p>
<p>就可以生成一个名为prog的可执行文件. 实际上的过程是, 先分别对main.c和sum.c调用cpp(C语言预处理器, 生成的中间文件后缀名为.i), ccl(C编译器,生成的汇编文件后缀名为.s), as(汇编器, 生成可重定位目标文件.o).</p>
<p>最后会调用链接器(ld, 将.o文件和其他所需的文件组合起来,创建可执行文件, linux下可执行文件的后缀名可以任意, 但一般没有后缀或者叫做out).</p>
<p>最后生成的可执行文件可以用 <kbd>./prog</kbd> 来执行, 执行的时候, shell会调用加载器(loader), 将prog中的程序和数据复制到内存, 然后将控制转移给程序开头.</p>
<p>GCC这样的LD是静态链接器, 接受的文件类型是.o文件, 每一个.o文件都由各种不同的代码节和数据节组成, 每一节都是一个连续的字节序列.链接器需要完成的主要任务是:</p>
<ol>
    <li>符号解析. 函数, 变量, 静态变量都是一个符号, 需要将每个符号引用与一个符号的定义关联起来</li>
    <li>重定位, 把每个符号定义与一个内存位置关联起来, 从而重定位.o文件中的所有代码节和数据节, 然后修改所有对于符号的引用, 将其指向对应的位置. 在上一步的汇编器生成的汇编文件中, 有帮助链接器工作的重定位条目.</li>
</ol>
<p>为了理解链接, 其实就是理解链接器的这两步工作.</p>

<h2 style="text-align: center;" id="con2">目标文件</h2>
<p>目标文件有三种:</p>
<ol>
    <li>可重定位目标文件, 就是汇编器生成的文件, 还需要进一步链接才能够形成可执行文件</li>
    <li>可执行目标文件, 包含二进制代码和数据, 其形式可以被直接复制到内存中执行</li>
    <li>共享目标文件, 这是特殊的可重定位目标文件, 可以在加载或者执行的时候动态的加载进内存并链接. 这个其实就是动态链接库.so</li>
</ol>
<p>目标文件有着不同的格式, 在Windows系统下是PE格式, Mac系统下是Mach-O格式, 而在Linux下是ELF格式.</p>
<p>先来看看可重定位目标文件结构, 以用的最多的ELF文件格式为例:</p>
<table>
    <tr>
        <td>索引0 ELF头 以一个特定的16字节序列开始, 描述了生成该文件的系统的字长和字节顺序. 剩下的部分帮助链接器语法分析和解释目标文件. 其中包括ELF头大小, 目标文件三种类型之一, 机器类型, 节头部表的偏移, 以及表中条目的大小和数量.
            <br>其中的节头部表描述了所有节的位置和大小, 每一个节在表里都有一个固定大小的条目 <br>
        简单的说, ELF描述了整个可执行文件的基础信息和结构.</td>
    </tr>
    <tr>
        <td>索引1 .text 已编译程序的机器代码</td>
    </tr>
    <tr>
        <td>索引2 .rodata 只读数据, 比如跳转表</td>
    </tr>
    <tr>
        <td>索引3 .data 已初始化的全局变量和静态C变量. 局部变量在运行时保存在栈中, 不会出现在这里和.bss节</td>
    </tr>
    <tr>
        <td>索引4 .bss 未初始化的全局和静态C变量, 以及所有被初始化为0的全局和静态变量. 这个仅仅是占位符, 不占用实际的空间. 在运行的时候在内存中分配这些变量</td>
    </tr>
    <tr>
        <td>索引5 .symtab 一个符号表, 存放所有定义和引用的函数和全局变量的信息, 不包含局部变量</td>
    </tr>
    <tr>
        <td>索引6 .rel.text .text节中位置的列表, 链接器在链接的时候需要修改这些位置</td>
    </tr>
    <tr>
        <td>索引7 .rel.data 被模块引用或定义的所有全局变量的重定位信息. 一般如果已经初始化的全局变量的值是一个全局变量地址或者外部定义函数, 都要修改这里.</td>
    </tr>
    <tr>
        <td>索引8 .debug 调试符号表, 其中的条目是程序中定义的局部变量和类型定义, 定义和引用的全局变量和原始的C源文件. 只有 gcc -g才有这张表.</td>
    </tr>
    <tr>
        <td>索引9 .line 原始C源程序的行号和.text中机器指令之间的映射, -g才会有这个表. </td>
    </tr>
    <tr>
        <td>索引10 .strtab 一个字符串表, 包括.symtab和.debug中的符号表, 以及节头部的名字. 这个就是一个以NULL结尾的字符串的序列.到这里都是节.</td>
    </tr>
    <tr>
        <td>节头部表, 描述整个目标文件的节.</td>
    </tr>
</table>
<p>这其中的关键是机器代码以及符号表. 符号表包含了所在的目标文件所有定义和引用的符号的信息.</p>
<p>对于链接器来讲, 有三种符号:</p>
<ol>
    <li>在当前模块中定义, 能够被其他模块引用的全局符号, 对应非静态的C函数和全局变量</li>
    <li>有其他模块定义, 并被当前模块引用的全局符号, 对应其他模块中定义的非静态C函数和全局变量</li>
    <li>只被当前模块定义和引用的局部符号, 对应与带static修饰的C函数和全局变量, 这些变量在m内部都可见, 在其他模块不可见.</li>
</ol>
<p>注意.symtab中不包含本地的, 不是静态的所有程序变量, 因为这些变量在运行的时候由过程在栈中管理. 链接器不会管理这种符号. 例外是用static 修饰的局部变量, 这种不是在栈中管理的, 编译器会在.data或者.bss中为每个定义分配空间, 然后在符号表中创建对应的符号.</p>
<p>例如:</p>
<pre>
int f(){
    static int x = 0;
}

int f(){
    static int x = 0;
}
</pre>
<p>这两个函数中的局部变量, 会被输出成两个不同名字的局部链接器符号.</p>
<p>简单的说, 在一个C文件里, 只有写在所有函数外边的变量, 所有函数和用static修饰的局部变量, 会出现在.symtab符号表中.</p>
<p>C语言实际上一个源文件代表一个模块, 用static修饰的模块级变量和函数, 都是对外不可见的.</p>
<p>使用GNU READELF程序可以查看目标文件的构成, 在<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html#" target="_blank">这里</a>找了一篇文章.</p>
<p>这里使用了 <kbd>readelf -all main.o</kbd> , 看到显示的结果: </p>
<pre>
Symbol table '.symtab' contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
     9: 0000000000000000    31 FUNC    GLOBAL DEFAULT    1 main
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum
</pre>
<p>可以看到符号表中包含其中三个, Num 指的是在字符串表中的偏移. value指的是距离所在的节的起始位置的偏移. Size表示大小, 以字节表示. Bind表示符号是本地的还是全局的. </p>
<p>后边的Ndx指的是所在的节. 节的顺序就按照上边ELF的索引顺序, 比如array就是索引为3也就是.data节, 偏移量为value=0的所在地.长度为8字节, 就是我们定义的两个int元素谁组成的数组.</p>
<p>main是长度为31字节, 定义在索引1 也就是.text节, 偏移量是0,也就是起始处的函数.</p>
<p>Ndx有三个特殊索引, 分别叫做ABS(不该被重定位的符号), UND(UNDEF, 未定义的符号, 即本模块中引用, 但是定义在其他地方的符号), COM(COMMON, 表示还未分配位置的未初始化的数据目标).</p>
<p>对于COMMON, value字段给出对齐要求, size给出最小的大小. 这三个特殊索引只在目标文件中存在, 链接之后的可执行文件是没有的.</p>
<h3>练习 7.1 符号表</h3>
<table>
    <thead>
    <tr>
        <th>符号</th>
        <th>.symtab条目?</th>
        <th>符号类型</th>
        <th>在哪个模块中定义</th>
        <th>节</th>
    </tr>
    </thead>
</table>







<h2 style="text-align: center;" id="con3"></h2>

<h2 style="text-align: center;" id="con4"></h2>

<h2 style="text-align: center;" id="con5"></h2>

<h2 style="text-align: center;" id="con6"></h2>

























<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
