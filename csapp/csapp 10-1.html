<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第十章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第十章笔记 系统级I/O</h1>

<p>终于来到了CSAPP的最后三章, 也是最后一个部分, 程序间的交互和通信. 终于从机器级的程序表示, 操作系统底层, 一直走到了应用级别.</p>

<ol>
    <li><a href="#con1">UNIX I/O</a></li>
    <li><a href="#con2">文件</a></li>
    <li><a href="#con3">打开和关闭文件</a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>

<h2 style="text-align: center;" id="con1">Unix I/O</h2>
<p>Linux的一大特点是一切皆文件. 一个文件就是一个字节序列, 所有的I/O设备(比如网络, 磁盘和终端)都被模型化为文件, 输入和输出都被当成文件的读写.</p>
<p>Linux 内核对于所有文件都使用一个统一的, 简单, 低级的应用接口, 这个接口就叫做Unix I/O. 常用的操作有:</p>
<ol>
    <li>打开文件. 一个应用程序通过向内核要求打开一个文件, 宣告要访问一个I/O设备. 内核会向其返回一个小的非负整数(小于255), 叫做描述符, 这个应用程序在后续可以使用描述符来代表这个文件. 这个文件相关的信息由内核维护, 应用程序只需要知道这个描述符就可以.</li>
    <li>每个进程有默认的三个文件描述符: 0 表示标准输入, 1 表示标准输出, 2表示标准错误输出. </li>
    <li>对于每个文件, 内核保存一个文件位置, 是一个整数. 初始是0, 指向文件开头. 这个数字表示这个文件距离开头的偏移量, 可以通过 seek 函数来显式的设置文件的当前位置.</li>
    <li>读文件. 读文件就是从文件的某个位置开始读一定长度的字节进内存. 如果读到文件的末尾, 会触发一个EOF条件, 表示到了文件末尾. 文件的实际末尾并没有一个EOF符号.</li>
    <li>写文件. 写文件就是从文件的某个位置开始将一定长度的字节写入文件, 如果超过文件的末尾, 文件会增大.</li>
    <li>关闭文件. 在使用完文件之后, 可以通知内核关闭这个文件. 内核会释放因为打开文件而创建的数据结构, 将描述符恢复到可用的描述符池中(即这个描述符如果没有重新分配, 当前进程就无法使用这个描述符). 当一个进程结束的时候, 内核会将其使用的所有描述符和对应文件统统关闭.</li>
</ol>


<h2 style="text-align: center;" id="con2">文件</h2>
<p>在这个博客此时的VPS上执行 <kbd>ls -la</kbd>, 可以看到如下输出:</p>
<pre>
[root@VM_0_7_centos ~]# ls -la
total 112
dr-xr-x---.  5 root root  4096 Jul 28 19:53 .
dr-xr-xr-x. 25 root root  4096 Aug  8 20:53 ..
-rw-------   1 root root 11215 Aug  5 15:17 .bash_history
-rw-r--r--.  1 root root    18 May 20  2009 .bash_logout
-rw-r--r--   1 root root   197 Jul 28 19:53 .bash_profile
-rw-r--r--.  1 root root   176 Sep 23  2004 .bashrc
-rw-r--r--.  1 root root   100 Sep 23  2004 .cshrc
-rw-r--r--   1 root root 26012 Jul 28 15:29 mysql80-community-release-el6-3.noarch.rpm
-rw-------   1 root root   289 Jul 28 19:43 .mysql_history
drwxr-xr-x   2 root root  4096 May 23 15:31 .pip
drwxr-----   3 root root  4096 Jul 28 16:25 .pki
-rw-r--r--   1 root root    73 May 23 15:31 .pydistutils.cfg
drwx------   2 root root  4096 Mar 16  2018 .ssh
-rw-r--r--.  1 root root   129 Dec  4  2004 .tcshrc
-rw-------   1 root root   801 Jul 28 16:33 .viminfo
-rwxr-xr-x   1 root root  4033 Mar 16  2017 vpn_centos.sh
-rw-r--r--   1 root root  4033 Mar 16  2017 vpn_centos.sh.1
-rw-r--r--   1 root root  4033 Mar 16  2017 vpn_centos.sh.2
-rw-r--r--   1 root root   931 May 23 15:33 wget-log
</pre>
<p>这个列出了在当前目录下的所有文件. 其实目录本身也是一个文件. 文件的类型就是在权限那一片的最开始一个字母:</p>
<ol>
    <li>普通文件. 用<code>-</code>表示, 包含任意的数据. 对于应用程序来说, 可能是文本文件或者二进制文件, 但对机器来讲都是二进制文件, 没有什么不同.</li>
    <li>目录文件. 用<code>d</code>表示, 这个文件包含一组链接, 链接到其他文件, 我们说被链接的文件存放在这个文件目录下. 每个目录至少含有两个条目, <code>.</code>指向当前路径, <code>..</code>指向上级路径.</li>
    <li>套接字. 是一个用来与另一个进程进行跨网络通信的文件.(本地套接字也可以用来在本机进程间通信)</li>
</ol>
<p>此外, 还有一些文件类型比如命名通道, 符号链接, 字符和块设备等, CSAPP不讨论这些.</p>
<p>linux将所有文件都组织成一个目录结构, 其中根目录是一个斜杠<code>/</code>, 系统中每个文件都是根目录的直接或者间接的后代.</p>
<p>每个进程还有一个当前工作目录, 由内核维护.</p>

<h2 style="text-align: center;" id="con3">打开和关闭文件</h2>
<p>这里的打开并不是C语言的打开, 而是系统级的打开.</p>
<p>进程可以通过调用系统open函数来打开文件, 如果成功, 会返回文件描述符. 如果失败, 会返回-1:</p>
<pre>
#include &lt;sys/type.h>
#include &lt;sys/stat.h>
#include &lt;fcntl.h>

int open(char *filename, int flags, mode_t mode);
</pre>
<p>第一个参数是文件名, 可以包含路径.</p>
<p>第二个参数表示要如何打开这个文件, 有如下宏可选:</p>
<ol>
    <li>O_RDONLY, 只读</li>
    <li>O_WRONLY, 只写</li>
    <li>O_RDWR, 可读可写</li>
    <li>O_CREAT, 如果文件不存在, 创建一个空白的文件</li>
    <li>O_TRUNC, 如果文件已经存在, 就截断(变成空白)掉</li>
    <li>O_APPEND, 在写操作之前, 将文件位置设置到文件的结尾</li>
</ol>
<p>后三个可以和前三个用或连接符来连接.</p>
<p>最后一个参数mode_t 表示权限位, 使用unmask的设置来指定文件的权限. 权限是和Linux的9个权限一一对应的. 这要先使用unmask参数, 再使用的打开文件的参数, CSAPP 624页的例子可以参考一下.</p>
<p>关闭文件则是使用close函数:</p>
<pre>
#include &lt;unistd.h>

int close(int fd);
</pre>



















<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
