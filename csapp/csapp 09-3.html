<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第四章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第九章 分配器的实现</h1>

<p>这一节通过讨论一些理论问题, 确定实现分配器的策略, 然后来写一个分配器. 确实刺激好玩. 其本质是操作一个链表数据结构.</p>

<ol>
    <li><a href="#con1">碎片</a></li>
    <li><a href="#con2">内存块的实际组织结构 - 隐式空闲链表</a></li>
    <li><a href="#con3">放置策略</a></li>
    <li><a href="#con4">如何合并相邻块</a></li>
    <li><a href="#con5">实现分配器</a></li>
    <li><a href="#con6"></a></li>
</ol>

<h2 style="text-align: center;" id="con1">碎片</h2>
<p>碎片是指的有未使用的内存, 但无法满足分配请求的时候, 就会产生碎片.</p>
<p>碎片分为内部碎片和外部碎片</p>
<ol>
    <li>内部碎片: 已分配块比有效载荷大. 比如一个程序申请5个字节的块, 但是malloc会按照8字节对齐来多分配3个字节, 有效载荷就是5, 而已分配块是8, 就产生了内部碎片</li>
    <li>外部碎片: 空闲内存合计满足条件, 但没有单独一个足够大的块可以直接整体放置需要的大小.</li>
</ol>
<p>由于外部碎片非常难预测, 所以分配器一般的策略是维持少量的大空闲块, 而不是大量的小空闲块.</p>

<h2 style="text-align: center;" id="con2">内存块的实际组织结构 - 隐式空闲链表</h2>
<p>在上一节的原理中, 看起来 malloc 就是简单的调用函数按照需求移动指针, 然后返回指针. 实际的细节不是如此. 为了分配内存, 系统会在刚分配的内存中维持一个数据结构, 用来区分块的边界, 区分已分配和未分配的块.</p>
<p>一个简单的块由如下部分组成:</p>
<ol>
    <li>头部信息, 一般长32位(一个字), 如果每个块都是8个对齐, 很显然块大小是8的倍数, 则最低三位二进制一定是0, 所以这三位是不使用的, 可以用最低位表示是否空闲, 另外两位暂时没有用处.</li>
    <li>有效载荷, 在头部之后的信息, 用于放置实际的程序运行中的数据</li>
    <li>填充, 这一部分根据分配的情况所定, 也可能没有填充.</li>
</ol>
<p>实际分配的块的大小, 等于上述三部分之和.</p>
<p>在这样一个一个分配之后, 实际上块在内存中组成了一个隐式链表. 即链表中的每个元素并没有直接包含指向下一个数据结构的指针, 但包含了当前节点的长度, 因此可以计算出下一个元素的指针.</p>
<p>为了标识结尾, 还可以约定一个长度为0, 但是已分配位为1的头部信息作为终止头部.</p>
<p>有了头部之后, 就要注意函数申请的实际空间与程序请求的空间之间的区别. 假如程序申请了4个字的空间, 很显然头部需要1个字, 然后载荷需要4个字, 合计5个字, 如果需要8个字对齐, 还需要填充3个字, 结果就是程序申请了4个字的空间, 实际消耗了8个字的内存空间. 同时还造成分配器上最小的块很显然不能是1个字, 而是要结合头部大小和对齐要求来决定.</p>
<p>分配器通过遍历这个链表, 可以找到所有空闲和不空闲的块.</p>
<h3>练习 9.6</h3>
<table>
    <thead>
    <tr>
        <th>请求</th>
        <th>块大小(十进制字节)</th>
        <th>块头部(十六进制)</th>
    </tr>
    </thead>

    <tbody>
    <tr>
        <td>malloc(1)</td>
        <td>请求1字节,但要双字对齐, 很显然头部需要一个字, 剩下1字节小于一个字, 因此也需要一个字,保持双字对齐, 所以长度是8字节.</td>
        <td>块头部是 0x9, 换成二进制是 0x1001, 第三位表示001=已分配, 这个1加在长度上就是9, 结果就是0x9. 注意块长度虽然是取了高位的29位, 但还是从最低位开始计算大小, 不是从倒数第四位开始计算大小的.</td>
    </tr>
    <tr>
        <td>malloc(5)</td>
        <td>请求5字节, 头部需要一个字 ,剩下5字节是1个字加1个字节, 由于双字对齐, 还需要填充3个字节和1个字, 总共4个字,长度是16字节</td>
        <td>就是0x10+1 = 0x11</td>
    </tr>
    <tr>
        <td>malloc(12)</td>
        <td>请求12个字节, 是3个字, 加上头上一个字也是4个字, 长度是16字节</td>
        <td>0x11</td>
    </tr>
    <tr>
        <td>malloc(13)</td>
        <td>请求13个字节, 是3个字加一个字节, 因此一共要6个字, 就是24个字节</td>
        <td>0x19</td>
    </tr>
    </tbody>
</table>

<h2 style="text-align: center;" id="con3">放置策略</h2>
<p>当一个应用请求k大小的块, 会查找空闲链表然后找到能够放入的地方, 决定放在哪里是由放置策略决定的.</p>
<p>常见的放置策略有:</p>
<ol>
    <li>首次适配: 从头开始找, 选择第一个合适的块</li>
    <li>下一次适配: 是从上一次查询结束的地方开始, 找到下一个合适的块</li>
    <li>最佳适配: 检查每个空闲块, 找到适合的最小的块</li>
</ol>
<p>在隐式链表结构中, 搜索的开销比较大, 下一次适配比首次适配要快, 然而内存利用率不高. 最佳适配的利用率最高, 但是要在其他的数据结构上实现, 不然每次都要搜索全链表.</p>
<p>如果找到了空闲块之后, 如果不能正好放下, 还要进行分割, 通常会选择将这个空闲块然后分割成两部分, 第一部分变成已分配, 第二部分变成未分配. 这就要对链表结构进行一些调整.</p>
<p>如果找不到空闲块, 就会调用sbrk函数来获取函数, 请求额外的堆内存, 然后将额外的内存转化为一个大的空闲块(即向里边写入链表数据结构), 然后把这个块加入到链表结尾, 再把数据放置在空闲块中.</p>
<p>如果一个空闲块被释放的时候, 有可能两个空闲块会相邻, 这些邻接的空闲块叫做假碎片. 因此必须要合并. 合并可以有多个选择, 比如在每次释放的时候, 立刻检查相邻的块, 也可能在后台定期扫描.</p>


<h2 style="text-align: center;" id="con4">如何合并相邻块</h2>
<p>如果操作过链表就是知道, 无论是目前的隐式链表, 还是显式链表, 只要知道一个节点, 都可以使用常数时间取得出下一个节点的地址. 所以合并下一个节点很方便, 只要每次 free 之后, 立刻检查下一个节点的标记, 如果是0就进行合并.</p>
<p>但是合并上一个节点就比较麻烦, 因为free 的参数直接就是一个指针, 要找到这个指针的上一个节点, 就要遍历链表直到找到, 这意味着每次free, 都要执行一个O(n)的操作.</p>
<p>高德纳(这人实在太牛逼了), 提出了一个算法, 就是在块数据结构的最后, 加上一个头部的复制. 这样每次完成 free 的时候, 只要将指针往回移动两个32位, 就是上一个指针的头部信息.</p>
<p>有了这个复制的头部之后, 无论前后都可以在常数时间内完成合并. 缺点就是又增加了一个字的空间, 如果程序反复使用很小的空间, 造成的空间浪费就太严重了.</p>
<p>所以还有了这个方法的优化, 就是将上一个节点是否已经分配, 放在当前节点没有用到的两个位中的一个, 这样已分配的块就无需脚部数据了. 只有空闲块需要脚部数据.</p>
<h3>练习 9.7 确定每种情况最小的块大小</h3>
<p>这个题目关键是要理解: 已经分配的块可以合并为空闲块, 空闲块可以和其他的合并. 所以已经分配的块的载荷至少有一个1字节.而空闲块是完全可以仅有头和尾, 没有载荷, 这样在合并的时候, 这种仅有头和尾的空闲块可以合并出一个新的字的空间.</p>
<table>
    <thead>
    <tr>
        <th>对齐要求</th>
        <th>已分配的块</th>
        <th>空闲块</th>
        <th>最小块大小(字节)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>单字对齐</td>
        <td>头部和脚部</td>
        <td>头部和脚部</td>
        <td>由于单字对齐, 最小载荷是1, 已分配块肯定是12字节, 而未分配块是8字节, 由于分配要按照大的来, 所以就是12字节</td>
    </tr>
    <tr>
        <td>单字对齐</td>
        <td>有头部,无脚部</td>
        <td>头部和脚部</td>
        <td>已分配块最小是1个头部加1个载荷是8字节, 而未分配是8字节, 所以最小块的大小是8字节</td>
    </tr>
    <tr>
        <td>双字对齐</td>
        <td>头部和脚部</td>
        <td>头手和脚部</td>
        <td>由于双字对齐, 已经分配是16字节, 空闲最小就是只有头和尾, 是8字节, 按照大的分配, 所以最小块是16字节</td>
    </tr>
    <tr>
        <td>双字对齐</td>
        <td>有头部, 无脚部</td>
        <td>头部和脚部</td>
        <td>有头部的最小载荷是8字节, 最小空闲块也是8字节, 所以就是8字节..</td>
    </tr>
    </tbody>
</table>

<h2 style="text-align: center;" id="con5">实现分配器</h2>

<h2 style="text-align: center;" id="con6"></h2>

























<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
