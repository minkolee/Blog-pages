<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第九章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>
        body {
            margin-left: 20px;
            margin-right: 20px;
        }
    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第九章 虚拟内存</h1>
<p>虚拟内存了, 到了CSAPP的最后三分之一了. 虚拟内存看了一下, 类似高速缓存是内存的映射, 虚拟内存也是一个映射的集合.</p>

<ol>
    <li><a href="#con1">地址</a></li>
    <li><a href="#con2">虚拟内存的组织结构 - 页表</a></li>
    <li><a href="#con3"></a></li>
    <li><a href="#con4"></a></li>
    <li><a href="#con5"></a></li>
    <li><a href="#con6"></a></li>
</ol>

<h2 style="text-align: center;" id="con1">地址</h2>
<p>虚拟内存和异常控制机制一样, 也是软硬结合的, 由硬件异常, 硬件地址翻译, 主存, 磁盘文件和内核软件的完美协作和交互组成. 为每个进程提供了一个大的, 一致的和私有的地址空间.</p>
<p>在日常使用中, 虚拟内存是不可见的, 自动工作的, 不需要应用程序员的干涉. 虚拟内存的特点有:</p>
<ol>
    <li>虚拟内存涉及计算机系统的所有层面</li>
    <li>虚拟内存给了应用程序强大的能力</li>
    <li>虚拟内存使用不当非常危险</li>
</ol>
<p>既然可以把虚拟内存抽象为一个地址空间, 那么很显然虚拟内存也有地址. 同时物理内存也有地址. 二者的地址空间不一定相同. 有些计算机采用物理地址寻址, 即寻址线路直接连接内存. 现代计算机都采用虚拟地址寻址, CPU生成虚拟地址, 虚拟地址通过硬件地址翻译器翻译成物理地址, 再接入内存单元.</p>
<p>CPU的地址和翻译硬件, 叫做内存管理单元, 或者内存控制单元. CPU的翻译利用的是存放在主存中的查询表来动态翻译虚拟地址, 这个查询表由操作系统管理, 所以这是软硬一体的流程.</p>
<p>地址空间是一个从0到最大内存编号的地址, CSAPP里假设都是线性也就是连续的. 虚拟内存有虚拟内存空间, 物理地址则有物理地址空间. 关键要认识到:</p>
<p style="color: red">主存的每一个字节, 都有一个来自虚拟地址空间的虚拟地址和来自物理地址空间的物理地址.</p>
<h3>练习 9.1 完成下边的表格</h3>
<table>
    <thead>
    <tr>
        <th>虚拟地址位数</th>
        <th>虚拟地址数</th>
        <th>最大可能的虚拟地址</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>8</td>
        <td>256</td>
        <td>256-1 = 255</td>
    </tr>
    <tr>
        <td>16</td>
        <td>64K = 2的16次方</td>
        <td>64K-1</td>
    </tr>
    <tr>
        <td>32位</td>
        <td>2的32次方</td>
        <td>2的32次方-1 = 4G-1</td>
    </tr>
    <tr>
        <td>48</td>
        <td>256T = 2的48次方</td>
        <td>256T-1</td>
    </tr>
    <tr>
        <td>64</td>
        <td>16E</td>
        <td>16E-1</td>
    </tr>
    </tbody>
</table>
<p>做完之后发现, 这其实是N位计算机能够支持的最大虚拟内存地址, 也是虚拟内存的大小. 常用的32位机器可以有4GB的虚拟内存地址空间, 而64位机器可以有16E的虚拟内存地址空间.</p>

<h2 style="text-align: center;" id="con2">虚拟内存的组织结构 - 页表</h2>
<p>虚拟内存被组织成为一个存放在磁盘上的连续N个字节大小的单元组成的数组. 每个字节有唯一的虚拟地址, 就是数组的索引. </p>
<p>注意, 这里提到了存放在磁盘上. 而这些存放在磁盘上的内容, 被缓存在主存中. 就像高速缓存有缓存块一样, 主存到磁盘之间的传输, 也被分成一个一个块.</p>
<p>虚拟内存系统将虚拟内存分割成大小固定的块, 这个块叫做虚拟页(Virtual Page). 类似的, 物理内存也被分割为物理页(也叫页帧), 大小与虚拟页相同.</p>
<p>所以虚拟内存可以看成是一个虚拟页的集合, 这个虚拟页的集合分为三个不相交的子集:</p>
<ol>
    <li>未分配的页: 虚拟内存系统还未分配(或者创建)的页. 没有任何数据何其关联.</li>
    <li>缓存的页: 已经缓存在物理内存中的已分配页</li>
    <li>未缓存的页: 没有缓存在物理内存中的已分配页</li>
</ol>
<p>虚拟页存储在磁盘上, 物理页缓存在DRAM中. 实际上高速缓存缓存了主存的内容, 而主存缓存了虚拟内存的内容. 虚拟内存则是存储在硬盘上的内容.</p>
<p>由于DRAM缓存不命中的开销很大, 所以虚拟内存的页一般都比较大, 不像高速缓存可能是几十个字节, 虚拟页一般是4K-2MB. DRAM是全相连的, 任何虚拟页都可以放在任何的物理页中.</p>
<p>DRAM缓存采取写回方式(设置一个标记, CPU写缓存的时候先检查标记, 如果标记是0就直接覆盖, 标记是1就先写内存, 再写缓存.这里的内存和缓存指的是两个级别的存储器, 并不特指硬件设备.)</p>
<p>和高速缓存一样, 虚拟内存系统必须判断一个虚拟页是不是缓存在DRAM的某个地方(就像CPU从内存读的时候, 可以判断这块内存是不是在缓存里). 如果虚拟页在DRAM缓存中, 则缓存命中. 如果不存在, 系统必须找到虚拟页在磁盘上的位置, 然后在物理内存中选择一个牺牲页, 将虚拟页从磁盘复制到DRAM中, 替换牺牲页.</p>
<p>这个功能软硬一体的, 开始说的存放在物理内存的, 供CPU翻译地址的查询表, 就是页表, 页表把虚拟页映射到物理页. 每次地址翻译硬件将虚拟地址翻译成物理地址的时候, 都会读取页表. 操作系统则负责维护页表的内容, 以及在磁盘和DRAM之间来回传送页.</p>
<p>页表实际上市一个数组, 其中的每一个元素叫做页表条目(Page Table Entry). 虚拟地址空间中的每个页在页表中的一个固定偏移量的位置处, 都有一个PTE. (这里好像高速缓存, 就是将虚拟缓存分成各个相等的块.)</p>
<p>PTE可以认为是由一个有效位, 外加一个地址字段组成的. 有效位表示这个页是不是已经缓存在DRAM中, 如果有效位被设置, 则地址字段表示DRAM中相应物理页的起始位置. 如果有效位没有设置, 就表示这个虚拟页还没有被分配, 则地址是空.</p>
<p>其实可以发现, 类似高速缓存, 虚拟页越大, 总共分的页数就越少, 则页表就越短. 页表的长度, 就是总的虚拟地址空间/页大小. </p>
<h3>9.2 确定页表的长度</h3>
<table>
    <thead>
    <tr>
        <th>n</th>
        <th>P=2的p次方</th>
        <th>PTE数量</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>16</td>
        <td>4K</td>
        <td>2e16/2e12 = 2e4 = 16</td>
    </tr>
    <tr>
        <td>16</td>
        <td>8K</td>
        <td>2e16/2e13 = 2e3 = 8</td>
    </tr>
    <tr>
        <td>32</td>
        <td>4K</td>
        <td>2e32/2e12 = 2e20 = 1M</td>
    </tr>
    <tr>
        <td>32</td>
        <td>8K</td>
        <td>2e32/2e13 = 2e19 = 512K</td>
    </tr>
    </tbody>
</table>
<p>知道了页表, 就类似高速缓存一样, 有命中与未命中了. CPU要读一个虚拟内存地址的时候, 地址翻译硬件会将其翻译成一个索引来定位要读取的页. 然后去检查页面, 因为有效位是1, 所以就会到内存中去读取, 读取的地址就是页表中的地址.</p>
<p>在虚拟内存的习惯说法中, DRAM缓存不命中叫做缺页(page fault), 地址翻译硬件在检查页表的时候, 发现有效位没有被设置, 这个时候硬件会触发一个缺页异常, 然后调用内核中的缺页异常处理程序, 这个程序会选择一个牺牲页, 如果牺牲页被修改了, 内核就会将其写回磁盘. 然后将其替换掉. 替换掉之后, 还会修改牺牲页和载入页的页表条目.</p>
<p>完成缺页替换之后, 还记得上一章的异常处理中缺页的处理方式, 是重新执行指令. 这个时候再去检查页表, 就会发现被缓存了, 然后读取之就可以了, 一切就像没有发生过缺页一样.</p>
<p>除了关键的页, 页表, 缺页等术语之外, 还有一些虚拟内存方面的名词:</p>
<ol>
    <li>交换(swapping): 在磁盘和内存之间传送页</li>
    <li>页面调度: 和交换是同一个意思</li>
    <li>换入: 页从磁盘载入DRAM</li>
    <li>换出: 页被从DRAM中弄走</li>
    <li>按需页面调度: 一直等到有不命中发生的时候才调度页面</li>
    <li>预测不命中: 尝试在不命中发生之前就调度页面</li>
</ol>
<p>听上去预测不命中会高端一些, 然而所有现代系统使用的都是按需页面调度的方式.</p>

<h2 style="text-align: center;" id="con3">通过虚拟内存管理内存</h2>
<p>虚拟内存简化了对内存的管理, 提供了一种保护内存的方法.</p>
<p>上一节学了基础的知识, 也就是以页表映射为核心, 将虚拟内存的内容在DRAM和磁盘间来回传送, 以满足程序的需要的基础过程.</p>
<p>实际上, 操作系统为每一个进程都提供了独立的页表, 因此每个进程看上去都会有独立的虚拟地址空间. 两个进程的虚拟地址即使相同, 映射的实际物理内存地址可以相同, 也可以不同.</p>
<p>这就为管理内存提供了深远的影响:</p>
<ol>
    <li>简化链接: 对于链接器来说, 并不需要知道实际的物理地址, 因为实际的物理地址因机器而已. 只需要知道虚拟地址即可, 所以就可以编译出位置无关的目标文件. 否则链接器就变成了针对不同内存大小要提供不同版本的软件了.</li>
    <li>简化加载: 在加载器加载程序的时候, 同样也无需自己去排布各个段的地址, 只需要按照固定的逻辑分配即可, 而且在分配的时候, 也不会实际复制任何数据, 只有按需的时候才会加载页面即读入数据.</li>
    <li>简化共享: 像之前我们编写的程序, 各个程序都需要系统调用, 需要将系统调用函数加载到所有程序的栈中吗? 有了虚拟内存, 显然不需要, 操作系统只需要将内核以及内核保留的一部分物理内存, 映射到每个进程的虚拟内存的同样一段地址上去. 所有的进程访问这些虚拟地址, 其实都是在访问同一个位置的物理内存.</li>
    <li>简化内存分配: 如果需要分配额外内存, 只需要分配一个连续的虚拟内存页面, 然后映射到物理内存中同样数量的物理页面就可以了, 而不需要分配连续的物理内容, 这就让分配变得容易许多.</li>
</ol>





<h2 style="text-align: center;" id="con4"></h2>

<h2 style="text-align: center;" id="con5"></h2>

<h2 style="text-align: center;" id="con6"></h2>

























<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
