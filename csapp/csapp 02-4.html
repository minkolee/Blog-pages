<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <title>第二章笔记</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons' rel="stylesheet">
    <style>

    </style>
</head>
<body>
<h1 style="text-align: center;">CSAPP 第二章 浮点数</h1>
<h2>二进制小数</h2>
<p>就像十进制小数一样，二进制的小数点左边是正幂，右边是负幂，只不过幂底由10变成2。小数点可以移动，左移表示除以2，右移表示乘以2。</p>
<p>同十进制小数只能精确表示10的幂组成的数一样，二进制小数也只能精确表示由2的幂组成的数。同十进制小数一样，如果想要更接近不能精确表示的数，只有通过增加位数来逐渐近似。</p>
<h3>2.45 二进制小数转换</h3>
<table>
    <thead>
    <tr>
        <th>小数值</th>
        <th>二进制表示</th>
        <th>十进制表示</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>1/8</td>
        <td>0.001</td>
        <td>0.125</td>
    </tr>
    <tr>
        <td>3/4</td>
        <td>0.11</td>
        <td>0.75</td>
    </tr>
    <tr>
        <td>25/16</td>
        <td>1.1001</td>
        <td>1.5625</td>
    </tr>
    <tr>
        <td>43/16</td>
        <td>10.1011</td>
        <td>2.6875</td>
    </tr>
    <tr>
        <td>9/8</td>
        <td>1.001</td>
        <td>1.125</td>
    </tr>
    <tr>
        <td>47/8</td>
        <td>101.111</td>
        <td>5.875</td>
    </tr>
    <tr>
        <td>51/16</td>
        <td>11.0011</td>
        <td>3.1875</td>
    </tr>
    </tbody>
</table>
<h3>2.46 导弹计时错误</h3>
<ol style="list-style-type: upper-alpha">
    <li>0.1的二进制表示是 0.000110011[0011],程序中的x是 0.00011001100110011001100。将两者对齐之后互相减一下：
    <pre>
        0.00011001100110011001100110011001100110011.....
        0.00011001100110011001100
    </pre>
    得到结果是 0.00000000000000000000000[1100]
    </li>
   <li>近似的10进制值是2的24次幂分之一加上2的25次幂分之一。</li>
   <li>100个小时之后，系统计数的次数运行了100*3600*10 = 3600000次。误差大概是0.343秒。</li>
   <li>2000*343 = 686米</li>
</ol>

<h2>IEEE浮点数表示</h2>
<p>浮点数分为单精度和双精度。单精度32位，双精度64位。其构成是：</p>
<ol>
    <li>单精度： 1位符号位，8位指数位，23位尾数</li>
    <li>双精度： 1位符号位，11位指数位，52位尾数</li>
</ol>
<p>符号位如果=0，表示是一个正数，是1，表示是一个负数。</p>
<p>指数位是最关键的位置，这个部分的数值，决定了这个浮点数的三种情况。以单精度为例：</p>
<ol>
    <li>指数位的原始二进制数是00000001——11111110，即不等于无符号的的上下限0和255，这表示规格化数，可以理解成表示一般的小数。这种情况下，指数等于无符号数的大小减去偏置数，尾数的部分自动变成1.尾数。</li>
    <li>指数位的原始二进制数是00000000，这个叫做非规格化数，此时尾数的部分就是.尾数，不再加上1。此时阶码固定等于1-偏置数。非规格化用来表示接近与0的数值。</li>
    <li>指数位的原始二进制数是11111111，这个是特殊值。如果此时尾数全部为0，则表示0，有+0和-0之分。如果尾数不为0，表示NaN。</li>
</ol>
<p>明白了小数的表示之后，就可以发现很有趣的现象，在都是正数的情况下，正好是按照无符号数逐渐增大来排列的。而负数排列的时候，就是按照降序来排列。</p>
<h3>练习题2.47 练习IEEE浮点数</h3>
<p>1个符号位，2个阶码位，2个尾数位的浮点数，偏置显然是1.</p>
<table border="1">
    <thead>
    <tr>
        <th>二进制</th>
        <th>e 无符号数</th>
        <th>E 减去偏置后的实际值</th>
        <th>阶数实际值</th>
        <th>f 表面尾数</th>
        <th>M 实际尾数</th>
        <th>2E*M 尾数实际值</th>
        <th>V 实际分数值</th>
        <th>十进制</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>0 00 00</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>0/4</td>
        <td>0/4</td>
        <td>0</td>
        <td>0</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>0 00 01</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1/4</td>
        <td>1/4</td>
        <td>1/4</td>
        <td>1/4</td>
        <td>0.25</td>
    </tr>
    <tr>
        <td>0 00 10</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1/2</td>
        <td>1/2</td>
        <td>1/2</td>
        <td>1/2</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>0 00 11</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>3/4</td>
        <td>3/4</td>
        <td>3/4</td>
        <td>3/4</td>
        <td>0.75</td>
    </tr>
    <tr>
        <td>0 01 00</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1.0</td>
    </tr>
    <tr>
        <td>0 01 01</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1/4</td>
        <td>5/4</td>
        <td>5/4</td>
        <td>5/4</td>
        <td>1.25</td>
    </tr>
    <tr>
        <td>0 01 10</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1/2</td>
        <td>3/2</td>
        <td>3/2</td>
        <td>3/2</td>
        <td>1.5</td>
    </tr>
    <tr>
        <td>0 01 11</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>3/4</td>
        <td>7/4</td>
        <td>7/4</td>
        <td>7/4</td>
        <td>1.75</td>
    </tr>
    <tr>
        <td>0 10 00</td>
        <td>2</td>
        <td>1</td>
        <td>2</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>2</td>
        <td>2.0</td>
    </tr>
    <tr>
        <td>0 10 01</td>
        <td>2</td>
        <td>1</td>
        <td>2</td>
        <td>1/4</td>
        <td>5/4</td>
        <td>5/2</td>
        <td>5/2</td>
        <td>2.5</td>
    </tr>
    <tr>
        <td>0 10 10</td>
        <td>2</td>
        <td>1</td>
        <td>2</td>
        <td>1/2</td>
        <td>3/2</td>
        <td>3</td>
        <td>3</td>
        <td>3.0</td>
    </tr>
    <tr>
        <td>0 10 11</td>
        <td>2</td>
        <td>1</td>
        <td>2</td>
        <td>3/4</td>
        <td>7/4</td>
        <td>7/2</td>
        <td>7/2</td>
        <td>3.5</td>
    </tr>
    </tbody>
</table>
<p>浮点数在越靠近0的地方越密集，在远离0的地方变稀疏。</p>
<p>通过实际操练，可以知道常见的浮点数的最大和最小范围。比如单精度浮点数，E最低取到1-127 = -126，尾数部分最低就是1，则就是2的-23次方，合起来最小数字就是2的-149次方。</p>
<p>最大数字则是E取到254，指数=254-127 = 127，尾数部分全是1，此时代表1.(23个1) = 2 - 2的-23次方。双精度的也就可知了。</p>
<h3>练习 2.48 解释练习2.6中的情况</h3>
<p>0x00359141写成二进制是：0000 0000 0011 0101 1001 0001 0100 0001。</p>
<p>0x4A564504写成二进制是：0100 1010 0101 0110 0100 0101 0000 0100。</p>
<p>移动一下找匹配的部分：</p>
<pre>
  00000000001<span style="color: red;">101011001000101000001</span>
    010010100<span style="color: red">101011001000101000001</span>00
</pre>
<p>现在就可以来解释这种匹配不是巧合的原因了。0x00359141的二进制，不补到32位的表示是<code>11 0101 1001 0001 0100 0001</code>。将其改成规格化数，则是<code>1.1 0101 1001 0001 0100 0001</code>。</p>
<p>这个时候可以看到，小数点往右移动了21位，单精度情况下，阶码的值应该等于127+21 = 148，即二进制的10010100。尾数部分注意由于是非规格化数，开头的1可以去掉，剩下21位在末尾补2个0。按照顺序写出的浮点数是：</p>
<pre>
    <span style="color: red">0</span> <span style="color: #1abc9c">10010100</span> <span style="color: orange">1 0101 1001 0001 0100 0001 00</span>
</pre>
<p>这就解释了为什么看起来像是整数的除了第一位1之外的部分被包含在浮点数中间一样。而且很显然，如果整数的二进制超过23位，精度就会有损失了。</p>
<h3>2.49 不能精确由浮点数表示的正整数</h3>
<p>从上边一个题目可以看出来，如果一个数字有N位二进制数，按照规格化分割之后第一位是1，后边有N-1位二进制表示，第一位1可以省略。而浮点数格式能存放n位，即 N-1 <= n。</p>
<p>即N<=n+1，所以当N = n+2的时候，如果尾数不是0，就会出现问题。因此最小的正整数，就是<code>2的n+1次方再加1</code>。</p>
<p>可以用很简单的方法推导，如果n=4，则5位2进制数都可以放下，因为最高1位去掉之后，还有4位可以精确表示。但是到了6位二进制，如果是100000，依然可以精确表示，因为没有尾数。</p>
<p>但是一旦有最后一位，比如100001，写成1.00001*2的5次方的时候，最后一个1就会丢失，所以对于4位尾数的浮点数，100001 = 33就无法精确表示了。</p>
<p>对于单精度浮点数，2的24次方+1这个整数就无法表示了。这个数字就是16777216+1 = 16777217</p>

<h2>舍入方向</h2>
<p>这个其实就是对尾数的操作的不同方式。</p>































<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>

</body>
</html>
