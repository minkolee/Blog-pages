<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Spring in Action 5 Chapter 02 学习记录</title>

</head>
<body>
<h1 style="text-align: center;">实现过程</h1>
<p>第二章其实并没有涉及到数据库，而是写了几个类，然后硬是new出来一些数据，写到页面中供选择。</p>
<p>主要的内容其实是Spring MVC的内容。</p>
<p>SIA5并没有区分Spring Framework和组件，而是直接就盯住Spring Boot讲起，从字面上不区分Spring 和Spring Boot，这是第四版相比第五版的一大改变。</p>


<h1 style="text-align: center;">构建数据库</h1>

<p>表结构和简单的数据如下：</p>
<img src="http://img.conyli.cc/spring/sia5schema.png" alt="SIA5数据结构图">
<p>创建数据结构，然后录入一些基础的原料及类别如下：</p>
<pre>
SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for ingredient
-- ----------------------------
DROP TABLE IF EXISTS `ingredient`;
CREATE TABLE `ingredient` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `type` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of ingredient
-- ----------------------------
INSERT INTO `ingredient` VALUES ('1', 'Flour Tortilla', 'WRAP');
INSERT INTO `ingredient` VALUES ('2', 'Corn Tortilla', 'WRAP');
INSERT INTO `ingredient` VALUES ('3', 'Ground Beef', 'PROTEIN');
INSERT INTO `ingredient` VALUES ('4', 'Carnitas', 'PROTEIN');
INSERT INTO `ingredient` VALUES ('5', 'Diced Tomatoes', 'VEGGIES');
INSERT INTO `ingredient` VALUES ('6', 'Lettuce', 'VEGGIES');
INSERT INTO `ingredient` VALUES ('7', 'Cheddar', 'CHEESE');
INSERT INTO `ingredient` VALUES ('8', 'Monterrey Jack', 'CHEESE');
INSERT INTO `ingredient` VALUES ('9', 'Salsa', 'SAUCE');
INSERT INTO `ingredient` VALUES ('10', 'Sour Cream', 'SAUCE');

-- ----------------------------
-- Table structure for order
-- ----------------------------
DROP TABLE IF EXISTS `orders`;
CREATE TABLE `orders` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `delivery_name` varchar(50) NOT NULL,
  `delivery_street` varchar(50) NOT NULL,
  `delivery_city` varchar(50) NOT NULL,
  `delivery_state` varchar(2) NOT NULL,
  `delivery_zip` varchar(10) NOT NULL,
  `cc_number` varchar(16) NOT NULL,
  `cc_expiration` varchar(5) NOT NULL,
  `cc_cvv` varchar(3) NOT NULL,
  `placed_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of order
-- ----------------------------

-- ----------------------------
-- Table structure for taco
-- ----------------------------
DROP TABLE IF EXISTS `taco`;
CREATE TABLE `taco` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of taco
-- ----------------------------

-- ----------------------------
-- Table structure for taco_ingredient
-- ----------------------------
DROP TABLE IF EXISTS `taco_ingredient`;
CREATE TABLE `taco_ingredient` (
  `taco_id` int(11) NOT NULL ,
  `ingredient_id` int(11) NOT NULL,
  KEY `taco_id_fk` (`taco_id`),
  KEY `ingre_id_fk` (`ingredient_id`),
  CONSTRAINT `ingre_id_fk` FOREIGN KEY (`ingredient_id`) REFERENCES `ingredient` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `taco_id_fk` FOREIGN KEY (`taco_id`) REFERENCES `taco` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of taco_ingredients
-- ----------------------------

-- ----------------------------
-- Table structure for taco_order
-- ----------------------------
DROP TABLE IF EXISTS `taco_order`;
CREATE TABLE `taco_order` (
  `order_id` int(11) NOT NULL,
  `taco_id` int(11) NOT NULL,
  KEY `taco_order_fk` (`taco_id`),
  KEY `taco_order_order_fk` (`order_id`),
  CONSTRAINT `taco_order_fk` FOREIGN KEY (`taco_id`) REFERENCES `taco` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `taco_order_order_fk` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of taco_order
-- ----------------------------
</pre>
<p>这里没有像原书一样使用四个英文字母当做ID，还是使用了标准的ID。</p>

<h1 style="text-align: center;">创建Ingredient类和对应的展示页面</h1>
<p>数据类都使用了lombok库，非常方便的库。<a href="https://projectlombok.org/features/all" target="_blank">这里</a>是一个简略的说明。</p>
<p>之后写Entity，基本上加上@Data和@NoArgsConstructor就可以了，然后可以将变量设置为final，只设置一次值就OK了。</p>
<p>现在的第一个问题是，Ingredient类如果里边设置了ENUM类，能成功映射吗。经过试验，不能能直接映射String类型的Type到Enum类。</p>
<p>这里DAO直接通过JPARepository接口来实现，除了默认的findAll()方法之外，自行添加了一个返回List&lt;String>的方法，用于返回所有Ingredient的类型。</p>
<p>Entity如下：</p>
<pre>
package cc.conyli.sia5.entity;

import lombok.AccessLevel;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;

import javax.persistence.*;

@Data
@RequiredArgsConstructor
@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)
@Entity
@Table(name = "ingredient")
public class Ingredient {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private final int id;
    @Column(name = "name")
    private final String name;
    @Column(name = "type")
    private final String type;
}
</pre>
<p>虽然使用了final，但是不影响取值，今后的Entity基本都这么写。</p>
<p>然后需要来编写模板文件。</p>
<p>这里需要注意的就是Thymeleaf中的<code>@{/css/style.css}</code>中的第一个<code>/</code>不能不写，否则会找不到地址。这个错误经常犯。</p>
<p>Thymeleaf模板的逻辑应该是先列出来所有的类型，再在所有的类型下边列出对应的内容。</p>
<p>为了达成这个目标，使用神奇的Spring Data 接口，编写了一个方法：</p>
<pre>List&lt;Ingredient> getIngredientsByType(String type);</pre>
<p>这中间IDE会自动提示，然后就可以使用了，会自动解析，超级神奇。</p>
<p>有了这个东西，外加取得的<code>List&lt;String></code>类型的列表，就可以给Model传入对应的内容了。</p>

<p>在编写页面的时候，原书就直接写死了几种类型，这里利用Service层对数据进行了处理，封装成一个Map对象，传给页面，就实现了动态的生成原料页面。</p>
<p>Service的方法如下：</p>
<pre>
@Override
    public Map&lt;String, List&lt;Ingredient>> getIngredientsAndTypeMap() {
        Map&lt;String, List&lt;Ingredient>> ingredientsByTypeMap = new HashMap&lt;>();

        List&lt;String> types = getTypes();

        for (String type : types) {
            ingredientsByTypeMap.put(type, getIngredientsByType(type));
        }

        return ingredientsByTypeMap;
    }
</pre>
<p>页面里使用嵌套循环，传给页面的变量名字叫mapper：</p>
<pre>
&lt;div class="container">
    &lt;h2 class="text-center">选择食材&lt;/h2>
    &lt;form th:action="@{/thyme/process}" action="#" method="post">
        &lt;div th:each="list: ${mapper}">
            &lt;h3 class="text-left" th:text="${list.key}">&lt;/h3>
            &lt;div class="form-check" th:each="ingredient: ${list.value}">
                &lt;input class="form-check-input" type="checkbox" th:value="${ingredient.id}" name="ingredients"
                       th:id="${ingredient.type}+${ingredient.id}">
                &lt;label class="form-check-label" th:text="${ingredient.name}"
                       th:for="${ingredient.type}+${ingredient.id}">&lt;/label>
            &lt;/div>
            &lt;hr>
        &lt;/div>
        &lt;input type="text" placeholder="mytaco">
        &lt;button type="submit">提交&lt;/button>
    &lt;/form>
&lt;/div>
</pre>

<h1 style="text-align: center;">创建Taco类和处理表单</h1>
<p>原书这一块的业务逻辑是，表单POST到一个地址，生成一个Taco对象，里边包含着所有的原料，ingredient属性里是一个id的列表，用一个List取出来。</p>
<p>为此需要创建Taco对象，要对应数据库，同时和Ingredient是多对多关系。这里就直接使用JPA和Hibernate相关的技术了。</p>
<p>一般我们从有多对多字段的地方查询比较好，由于原料是比较基础的，仅作为提供数据只用，所以把多对多字段放在Taco类里。</p>
<p style="color: red">这里自己发现了一个坑。一开始将taco表的创建时间列名设置为 createdAt，在taco类里也写了@Column(name = "createdAt")，结果Hibernate自动去找叫做created_at的列，找不到。</p>
<p>深入一下研究，发现这是Spring JPA解析列名的设置，配置文件里可以设置解析方式，有两种：</p>
<pre>
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
</pre>
<p>上边一种是不对列名进行任何处理，而下边就是Spring的，会自动将@Column中的大写部分拆开成两个单词以下划线拼接。</p>
<p>如果不进行任何修改，配置成上边这样，就OK了，然而以后还是得注意mysql的命名规范。</p>
<p>创建好的Taco类如下：</p>
<pre>
package cc.conyli.sia5.entity;

import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;


@Data
@Entity
@Table(name = "taco")
public class Taco {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    @Column(name = "name")
    private String name;
    @Column(name = "created_at")
    private Date createdAt;

    @ManyToMany(cascade = {CascadeType.DETACH, CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH})
    @JoinTable(name = "taco_ingredient", joinColumns = @JoinColumn(name = "taco_id"), inverseJoinColumns = @JoinColumn(name = "ingredient_id"))
    private List&lt;Ingredient> ingredients;

    @PrePersist
    void createdAt() {
        this.createdAt = new Date();
    }
    //添加一个方法用于给自己的外键添加关联对象，这个实际上用不到
    //在控制器绑定了表单的时候，Taco对象的外键属性里会直接由Spring Data JPA装上查询好以后的对象，可以直接保存。
    public void addIngredient(Ingredient ingredient) {
        if (ingredients == null) {
            ingredients = new ArrayList<>();
        }
        ingredients.add(ingredient);
    }
}
</pre>
<p>之后是要创建控制器，service和dao，这里的DAO依然直接继承神奇接口，service现在只需要编写一个save方法，控制器现在只需要编写一个处理表单然后保存的方法。service层和DAO层的代码就省略了。</p>
<p>看一下Taco控制器，就一个方法，处理表单然后保存。</p>
<pre>
package cc.conyli.sia5.controller;

import cc.conyli.sia5.entity.Taco;
import cc.conyli.sia5.service.TacoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/taco")
public class TacoController {

    private TacoService tacoService;

    @Autowired
    public TacoController(TacoService tacoService) {
        this.tacoService = tacoService;
    }

    @PostMapping("/process")
    public String saveTaco(@ModelAttribute("taco") Taco taco) {
        System.out.println(taco);
        tacoService.save(taco);
        System.out.println(taco);
        return "redirect:/";
    }
}
</pre>
<p>之后还需要做一步，就是给表单绑定对象，由于之前展示表单的时候还没有绑定Taco对象，这里需要绑定，还要一并修改下边的name对应的input：</p>
<pre>
&lt;form th:action="@{/taco/process}" action="#" method="post" <span style="color: red">th:object="${taco}"</span>>
&lt;input type="text" <span style="color: red;">th:field="*{name}"</span> placeholder="mytaco">
</pre>
<p>这样我们就完成了选择食材--提交表单--保存Taco与食材的对应关系的功能。</p>
<p>然后可以接下来实现下一步功能了，就是生成一个订单，里边装着这个Taco，提交订单之后保存到数据库，在订单页面可以选择再添加一个Taco，最后把订单对应的taco全部保存到其中去。</p>
<p>原书的实现方法，是在生成原料列表的控制器里使用了一个<code>@SessionAttributes("order")</code>，然后有一个方法：</p>
<pre>
@ModelAttribute(name = "order")
public Order order() {
return new Order();
}
</pre>
<p>这个方法似乎是设置了一个新的Order对象。然后在处理表单的时候，如果Taco对象成功获取，就将Taco设置到Order的外键对象上。</p>
<p>在接受order的请求方法中，多了一个参数SessionStatus，在成功保存了session之后，调用了<code>SessionStatus.setComplete()</code>方法，猜测是这样：</p>
<p>设置了一个order属性的时候，即使再设置新的order，也不会覆盖原来的，只会再得到原来的对象。</p>
<p>只有调用了<code>SessionStatus.setComplete()</code>之后，才会清理session。</p>
<p>也就是说即使去添加<code>model.addAttribute("order", new Order())</code>也不会覆盖原来的order了。</p>
<p>这里有点困惑，经过实际试验，设置不同的session对象会互相影响。</p>
<p>不管如何，先把Order类，还有提交食材的时候自动跳转填写Order类的工作准备好。</p>
<p>Order类如下，这里一开始犯了一个错误，就是把表名起成了MySQL的保留字order，导致一直出错，后来改成了orders就可以了：</p>
<pre>
package cc.conyli.sia5.entity;

import lombok.Data;

import javax.persistence.*;
import java.util.Date;
import java.util.List;

@Data
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Column(name = "delivery_name")
    private String delivery_name;

    @Column(name = "delivery_street")
    private String delivery_street;

    @Column(name = "delivery_city")
    private String delivery_city;

    @Column(name = "delivery_state")
    private String delivery_state;

    @Column(name = "delivery_zip")
    private String delivery_zip;

    @Column(name = "cc_number")
    private String cc_number;

    @Column(name = "cc_expiration")
    private String cc_expiration;

    @Column(name = "cc_cvv")
    private String cc_cvv;

    @Column(name = "placed_at")
    private Date placed_at;

    @ManyToMany(cascade = {CascadeType.DETACH, CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH})
    @JoinTable(name = "taco_order", joinColumns = @JoinColumn(name = "order_id"), inverseJoinColumns = @JoinColumn(name = "taco_id"))
    private List&lt;Taco> tacos;

    @PrePersist
    private void placedAt() {
        this.placed_at = new Date();
    }
}
</pre>
<p>然后是表单页面，写得比较死，绑定由model传进来的order空白order对象：</p>
<pre>
&lt;div class="container">
    &lt;form action="#" th:action="@{/order/process}" th:object="${order}" method="post">
        &lt;h3 class="text-center">提交订单&lt;/h3>
        &lt;div class="form-group">
            &lt;label>delivery_name
                &lt;input class="form-control" type="text" th:field="*{delivery_name}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>delivery_street
                &lt;input class="form-control" type="text" th:field="*{delivery_street}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>delivery_city
                &lt;input class="form-control" type="text" th:field="*{delivery_city}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>delivery_state
                &lt;input class="form-control" type="text" th:field="*{delivery_state}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>delivery_zip
                &lt;input class="form-control" type="text" th:field="*{delivery_zip}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>卡号
                &lt;input class="form-control" type="text" th:field="*{cc_number}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>过期日
                &lt;input class="form-control" type="text" th:field="*{cc_expiration}" placeholder="...">
            &lt;/label>
        &lt;/div>

        &lt;div class="form-group">
            &lt;label>CVV2码
                &lt;input class="form-control" type="text" th:field="*{cc_cvv}" placeholder="...">
            &lt;/label>
        &lt;/div>
        &lt;a th:href="@{/ingredients}" class="btn btn-primary">给订单添加新Taco&lt;/a>
        &lt;button type="submit" class="btn btn-primary">提交&lt;/button>

    &lt;/form>
&lt;/div>
</pre>
<p>最后是简单的控制器：</p>
<pre>
package cc.conyli.sia5.controller;

import cc.conyli.sia5.dao.OrderRepository;
import cc.conyli.sia5.entity.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Slf4j
@Controller
@RequestMapping("/order")
public class OrderController {

    private OrderRepository orderRepository;

    @Autowired
    OrderController(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }


    @GetMapping("/form")
    public String showOrderForm(Model model) {
        model.addAttribute("order", new Order());
        return "order";
    }

    @PostMapping("/process")
    public String processOrder(@ModelAttribute("order") Order order) {
        orderRepository.save(order);
        log.info("保存的order是：" + order);
        return "redirect:/";
    }


}
</pre>
jdbc:h2:mem:testdb
<p>先来按照SIA5做一遍看看，发现不行，每次新的session会覆盖掉原来的session内的order键值。</p>
<p>这里还需要注意的是，如果Order多对多列表里的内容已经被先存储，而不是取出一个已经存在的数据，或者是尚未存储的数据，需要去掉多对多字段的：<code>CascadeType.PERSIST</code>。</p>
<p>这里有点晕菜，@SessionAttributes和@ModelAtrribute到底是什么样的关系，是不是默认直接取Order order又是什么。</p>




















</body>
</html>