<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="base.css">
    <title>Spring in Action 5 Self-learning notes 4 - REST API</title>
</head>
<body>
<p>这一章下了源码包一看，已经是写好的整个Cloud项目，还不知道怎么用，另外前端用的是Angular取数，虽然能够看懂Angular做了什么，但是毕竟还是不懂，比较费劲。</p>
<p>痛定思痛，主要还是之前Django 开发的时候没有好好的接触前后端分离的项目，这次立刻去找了Vue的视频，也要重新学起Vue来了。</p>
<p>于是这一章自己再弄一个简单的系统，把SIA5里第六章的技术都实验一遍。</p>

<h1 style="text-align: center;">数据库设计</h1>
<p>这次简单一些，先弄一个外键一对多的例子，一个student表，一个course表，学生外键关联到course表。</p>
<p>SQL如下：</p>
<pre>
SET FOREIGN_KEY_CHECKS=0;


-- ----------------------------
-- Table structure for course
-- ----------------------------
DROP TABLE IF EXISTS `course`;
CREATE TABLE `course` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `course_name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of course
-- ----------------------------
INSERT INTO `course` VALUES ('1', 'Java Programming');
INSERT INTO `course` VALUES ('2', 'Discrete mathematics');
INSERT INTO `course` VALUES ('3', 'Software engineering');
INSERT INTO `course` VALUES ('4', 'Design Pattern');
-- ----------------------------
-- Table structure for student
-- ----------------------------
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) NOT NULL,
  `last_name` varchar(255) NOT NULL,
  `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `course_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `student_course_fk` (`course_id`),
  CONSTRAINT `student_course_fk` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of student
-- ----------------------------
INSERT INTO `student` VALUES ('1', 'Angelo', 'Gladstone', '2019-04-09 10:42:29', '1');
INSERT INTO `student` VALUES ('2', 'Ronald', 'Constance', '2019-04-09 10:43:21', '1');
INSERT INTO `student` VALUES ('3', 'Sabina', 'Wood', '2019-04-09 10:43:19', '2');
INSERT INTO `student` VALUES ('4', 'Rachel', 'Isaac', '2019-04-09 10:43:16', '2');
INSERT INTO `student` VALUES ('5', 'Veronica', 'Katrine', '2019-04-09 10:43:38', '2');
INSERT INTO `student` VALUES ('6', 'Wordsworth', 'Clement', '2019-04-09 10:43:51', '2');
INSERT INTO `student` VALUES ('7', 'Paula', 'Aled', '2019-04-09 10:44:01', '3');
INSERT INTO `student` VALUES ('8', 'Diana', 'Hughes', '2019-04-09 10:44:12', '3');
INSERT INTO `student` VALUES ('9', 'Maurice', 'Eveline', '2019-04-09 10:44:24', '4');
INSERT INTO `student` VALUES ('10', 'Dominic', 'Toynbee', '2019-04-09 10:44:33', '4');
INSERT INTO `student` VALUES ('11', 'Aries', 'Browning', '2019-04-09 10:44:44', '1');
INSERT INTO `student` VALUES ('12', 'Gary', 'Ward', '2019-04-09 10:44:55', '2');
INSERT INTO `student` VALUES ('13', 'Lindsay', 'Newton', '2019-04-09 10:45:03', '2');
INSERT INTO `student` VALUES ('14', 'Leo', 'Hansen', '2019-04-09 10:45:13', '3');
INSERT INTO `student` VALUES ('15', 'Ingrid', 'Julia', '2019-04-09 10:45:22', '4');
</pre>

<h1 style="text-align: center;">配置数据库和Entity设计</h1>
<p>用Spring Initializr创建项目，依赖先选Web，Thymeleaf，JPA，lombok和mysql驱动，安全先不选了。</p>
<p>这里还是继续沿用原来的配置：</p>
<pre>
spring.datasource.url=jdbc:mysql://localhost:3306/sia5?useSSL=false&serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=springstudent
spring.datasource.password=springstudent

spring.thymeleaf.cache=false
spring.thymeleaf.encoding=UTF-8
</pre>
<p>之后就是写对应的entity类：</p>
<pre>
package cc.conyli.restlearn.entity;

import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@NoArgsConstructor(force = true)
@Table(name = "course")
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private final int id;

    private final String courseName;


    @OneToMany(fetch = FetchType.LAZY, mappedBy = "courseId")
    private final List&lt;Student> students = new ArrayList&lt;>();

    void add(Student student) {
        this.students.add(student);
    }

}
</pre>
<pre>
package cc.conyli.restlearn.entity;

import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Data
@Entity
@Table(name = "student")
@NoArgsConstructor(force = true)
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private final int id;

    private final String firstName;

    private final String lastName;

    //这里先不设置外键，否则JSON化之后会来回引用，无尽循环
    private final int courseId;

}
</pre>

<h3 style="text-align: center;">RestController-Retrieve功能</h3>
<p>先写一个简单的REST控制器，用于取所有课程和学生，单个课程和学生</p>
<pre>
package cc.conyli.restlearn.controller;

import cc.conyli.restlearn.entity.Course;
import cc.conyli.restlearn.entity.Student;
import cc.conyli.restlearn.repository.CourseRepo;
import cc.conyli.restlearn.repository.StudentRepo;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.Optional;


@org.springframework.web.bind.annotation.RestController
@RequestMapping(path = "/api", produces = "application/json")
@CrossOrigin("*")
public class RestController {

    private StudentRepo studentRepo;
    private CourseRepo courseRepo;

    public RestController(StudentRepo studentRepo, CourseRepo courseRepo) {
        this.courseRepo = courseRepo;
        this.studentRepo = studentRepo;
    }

    @GetMapping("/students")
    public Iterable&lt;Student> showStudentList() {
        return studentRepo.findAll();
    }

    @GetMapping("/courses")
    public Iterable&lt;Course> showCourseList() {
        return courseRepo.findAll();
    }

    @GetMapping("/student/{id}")
    public Student getStudent(@PathVariable int id) {
        Optional&lt;Student> student = studentRepo.findById(id);
        return student.orElse(null);
    }

    @GetMapping("/course/{id}")
    public Course getCourse(@PathVariable int id) {
        Optional&lt;Course> course = courseRepo.findById(id);
        return course.orElse(null);
    }
}
</pre>
<p><code>@RestController</code>注解已经知道了，这个是将返回的内容转换成字符串后直接写到请求体中，不通过视图解析器去找视图。这个注解其实可以拆解成<code>@Controller</code>和<code>@ResponseBody</code>两个注解，但还是用一个语义更加明确。</p>
<p><code>@RequestMapping</code>也更进了一步，带上了路径参数和后边的produces参数，如此设置就让这个控制器仅接受请求头里Accept包含application/json的请求，针对这个新建了一个项目，试验成功。</p>
<p>然后是一个允许跨域的<code>@CrossOrigin("*")</code>，设置为*表示任何跨域来的请求都可以处理。一般AJAX设置为不跨域，外加自己的方法不对外提供跨域服务，就很安全了。</p>
<p>这里注意，没有返回字符串，直接返回List，这就是借助了Jackson自动转换成Json。</p>
<p>这个控制器里需要改进的是后边两个返回单个对象的方法。首先这里是Java8的特性，就是写成函数式的方法，使用<code>orElse</code>来判断，如果不为空就返回结果，为空就返回null。</p>
<p>此时去实验，发现一个问题是，虽然没找到结果，但是依然返回响应体为空的200响应。但实际上没有找到对象，应该返回一个404错误，此时可以返回<code>ResponseEntity</code>对象，可以设置响应。</p>
<p>将两个方法修改如下：</p>
<pre>
@GetMapping("/student/{id}")
public ResponseEntity&lt;Student> getStudent(@PathVariable int id) {
    Optional&lt;Student> student = studentRepo.findById(id);
    if (student.isPresent()) {
        return new ResponseEntity&lt;>(student.get(), HttpStatus.OK);
    }else {
        return new ResponseEntity&lt;>(null, HttpStatus.NOT_FOUND);
    }
}

@GetMapping("/course/{id}")
public ResponseEntity&lt;Course> getCourse(@PathVariable int id) {
    Optional&lt;Course> course = courseRepo.findById(id);
    if (course.isPresent()) {
        return new ResponseEntity&lt;>(course.get(), HttpStatus.OK);
    }else {
        return new ResponseEntity&lt;>(null, HttpStatus.NOT_FOUND);
    }
}
</pre>
<p>这样这两个方法在找不到的时候，就会返回404错误，<code>ResponseEntity</code>非常好用。</p>

<h3 style="text-align: center;">RestController-Create功能</h3>
<p>添加功能已经知道了，就是给指定的路径接受POST方法，然后绑定传入的JSON对象即可。</p>
<pre>
@PostMapping(path = "/students", consumes = "application/json")
@ResponseStatus(HttpStatus.CREATED)
public Student addStudent(@RequestBody Student student) {
    log.info(student.toString());
    return studentRepo.save(student);
}

@PostMapping(path = "/courses", consumes = "application/json")
@ResponseStatus(HttpStatus.CREATED)
public Course addStudent(@RequestBody Course course) {
    log.info(course.toString());
    return courseRepo.save(course);
}
</pre>
<p>这里的关键是<code>@RequestBody</code>绑定Taco对象，现在学过好多玩意了，比如<code>@RequestParam</code>绑定URL参数，<code>@PathVariable</code>绑定路径变量，@ModelAttribute绑定各种数据对象。</p>
<p>consumes="application/json"是针对数据input来说的，只能接受Content-type=application/json的数据，和produce略有区别。</p>
<p><code>@ResponseStatus(HttpStatus.CREATED)</code>用于具体控制响应代码，如果不特殊设置，只要没有异常，都会返回200，但对于这个功能，CREATED=201更加精确，浏览器端也可以知道，不仅访问成功，对象也成功建立了。</p>
<p>启动项目可以实验，如果以其他形式Post过去，都不行，必须以JSON格式才可以。</p>

<h3 style="text-align: center;">RestController-Update功能</h3>
<p>Update用使用<code>@PutMapping</code>和<code>@PatchMapping</code>。PUT一般用于整个替换成新的，而PATCH一般用于部分更新。举个例子：</p>
<pre>
@PutMapping(value = "/student/{id}", consumes = "application/json")
public ResponseEntity&lt;Student> replaceStudent(@PathVariable("id") int id, @RequestBody Student student) {
    Optional&lt;Student> targetStudent = studentRepo.findById(id);
    if (targetStudent.isPresent()) {
        Student theStudent = targetStudent.get();
        theStudent.setFirstName(student.getFirstName());
        theStudent.setLastName(student.getLastName());
        theStudent.setCourseId(student.getCourseId());
        return new ResponseEntity&lt;>(studentRepo.save(theStudent), HttpStatus.ACCEPTED);
    }else {
        return new ResponseEntity&lt;>(null, HttpStatus.NOT_FOUND);
    }
}
</pre>
<p>这个PUT方法要求传入一个完整的Student对应的JSON数据，否则就会因为设置成null而写入失败，数据传输的量比较大。而如果用PATCH更新部分，就好很多了：</p>
<pre>
@PatchMapping(path = "/student/{id}", consumes = "application/json")
public ResponseEntity&lt;Student> patchStudent(@PathVariable("id") int id, @RequestBody Student student) {
    Optional&lt;Student> targetStudent = studentRepo.findById(id);
    if (targetStudent.isPresent()) {
        Student theStudent = targetStudent.get();
        if (student.getFirstName() != null) {
            theStudent.setFirstName(student.getFirstName());
        }
        if (student.getLastName() != null) {
            theStudent.setLastName(student.getLastName());
        }
        if (student.getCourseId() != null) {
            theStudent.setCourseId(student.getCourseId());
        }
        return new ResponseEntity&lt;>(studentRepo.save(theStudent), HttpStatus.ACCEPTED);
    } else {
        return new ResponseEntity&lt;>(null, HttpStatus.NOT_FOUND);
    }
}
</pre>
<p>这样通过判断哪些字段不为空，可以只更新有值的字段，注意这里的int是不能直接与null进行比较，所以这里需要修改Entity类中的外键为Integer类型。</p>
<p>注意，PUT和PATCH仅仅是语义，实际代码怎么写，和语义是没有关系的。在实际写项目的时候，要规定好自己的各个URL和接受的请求方法才行。</p>

<h3 style="text-align: center;">RestController-Delete功能</h3>
<p>Delete功能一般无需返回任何结果，哪怕找不到请求对象，因为请求对象不存在本身就说明删除的目的达到了。</p>
<p>SIA5里是直接调用Repo的删除方法，然后去抓异常，都返回204响应。这里修改了一下代码，如果找不到还是返回一个404吧，在前端还能区分出来具体结果。</p>
<pre>
@DeleteMapping(path = "/student/{id}", consumes = "application/json")
public ResponseEntity&lt;Student> removeStudent(@PathVariable("id") int id) {
    Optional&lt;Student> targetStudent = studentRepo.findById(id);
    if (targetStudent.isPresent()) {
        studentRepo.delete(targetStudent.get());
        return new ResponseEntity&lt;>(null, HttpStatus.NO_CONTENT);
    }else {
        return new ResponseEntity&lt;>(null, HttpStatus.NOT_FOUND);
    }
}
</pre>














</body>
</html>